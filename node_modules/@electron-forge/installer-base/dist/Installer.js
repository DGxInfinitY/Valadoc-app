"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Installer {
  /* tslint:disable variable-name */

  /* tslint:enable variable-name */
  constructor() {
    _defineProperty(this, "name", void 0);

    _defineProperty(this, "__isElectronForgeInstaller", void 0);

    Object.defineProperty(this, '__isElectronForgeInstaller', {
      value: true,
      enumerable: false,
      configurable: false
    });
  }
  /**
   * Installers must implement this method and install the given filePath
   * when called.  This method must return a promise
   */


  install(opts) {
    var _this = this;

    return _asyncToGenerator(function* () {
      throw new Error(`Installer ${_this.name} did not implement the install method`);
    })();
  }

}

exports.default = Installer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9JbnN0YWxsZXIudHMiXSwibmFtZXMiOlsiSW5zdGFsbGVyIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsImluc3RhbGwiLCJvcHRzIiwiRXJyb3IiLCJuYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFPZSxNQUFlQSxTQUFmLENBQXlCO0FBRXRDOztBQUVBO0FBRUFDLEVBQUFBLFdBQVcsR0FBRztBQUFBOztBQUFBOztBQUNaQyxJQUFBQSxNQUFNLENBQUNDLGNBQVAsQ0FBc0IsSUFBdEIsRUFBNEIsNEJBQTVCLEVBQTBEO0FBQ3hEQyxNQUFBQSxLQUFLLEVBQUUsSUFEaUQ7QUFFeERDLE1BQUFBLFVBQVUsRUFBRSxLQUY0QztBQUd4REMsTUFBQUEsWUFBWSxFQUFFO0FBSDBDLEtBQTFEO0FBS0Q7QUFFRDs7Ozs7O0FBSU1DLEVBQUFBLE9BQU4sQ0FBY0MsSUFBZCxFQUFzQztBQUFBOztBQUFBO0FBQ3BDLFlBQU0sSUFBSUMsS0FBSixDQUFXLGFBQVksS0FBSSxDQUFDQyxJQUFLLHVDQUFqQyxDQUFOO0FBRG9DO0FBRXJDOztBQXBCcUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPcmFJbXBsIH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL2FzeW5jLW9yYSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5zdGFsbGVyT3B0aW9ucyB7XG4gIGZpbGVQYXRoOiBzdHJpbmc7XG4gIGluc3RhbGxTcGlubmVyOiBPcmFJbXBsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBJbnN0YWxsZXIge1xuICBhYnN0cmFjdCBuYW1lOiBzdHJpbmc7XG4gIC8qIHRzbGludDpkaXNhYmxlIHZhcmlhYmxlLW5hbWUgKi9cbiAgX19pc0VsZWN0cm9uRm9yZ2VJbnN0YWxsZXIhOiBib29sZWFuO1xuICAvKiB0c2xpbnQ6ZW5hYmxlIHZhcmlhYmxlLW5hbWUgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19faXNFbGVjdHJvbkZvcmdlSW5zdGFsbGVyJywge1xuICAgICAgdmFsdWU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFsbGVycyBtdXN0IGltcGxlbWVudCB0aGlzIG1ldGhvZCBhbmQgaW5zdGFsbCB0aGUgZ2l2ZW4gZmlsZVBhdGhcbiAgICogd2hlbiBjYWxsZWQuICBUaGlzIG1ldGhvZCBtdXN0IHJldHVybiBhIHByb21pc2VcbiAgICovXG4gIGFzeW5jIGluc3RhbGwob3B0czogSW5zdGFsbGVyT3B0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFsbGVyICR7dGhpcy5uYW1lfSBkaWQgbm90IGltcGxlbWVudCB0aGUgaW5zdGFsbCBtZXRob2RgKTtcbiAgfVxufVxuIl19