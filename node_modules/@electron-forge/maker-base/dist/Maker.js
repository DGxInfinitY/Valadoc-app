"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Maker {
  /* tslint:disable variable-name */

  /* tslint:enable variable-name */
  constructor(configFetcher = {}, providedPlatforms) {
    this.configFetcher = configFetcher;
    this.providedPlatforms = providedPlatforms;

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "name", void 0);

    _defineProperty(this, "defaultPlatforms", void 0);

    _defineProperty(this, "__isElectronForgeMaker", void 0);

    Object.defineProperty(this, '__isElectronForgeMaker', {
      value: true,
      enumerable: false,
      configurable: false
    });
  }

  get platforms() {
    if (this.providedPlatforms) return this.providedPlatforms;
    return this.defaultPlatforms;
  } // TODO: Remove this, it is an eye-sore and is a nasty hack to provide forge
  //       v5 style functionality in the new API


  prepareConfig(targetArch) {
    if (typeof this.configFetcher === 'function') {
      this.config = this.configFetcher(targetArch);
    } else {
      this.config = this.configFetcher;
    }
  }
  /**
   * Makers must implement this method and return true or false indicating whether
   * this maker can be run on the current platform.  Normally this is just a process.platform
   * check but it can be a deeper check for dependencies like fake-root or other
   * required external build tools.
   *
   * If the issue is a missing dependency you should log out a HELPFUL error message
   * telling the developer exactly what is missing and if possible how to get it.
   */


  isSupportedOnCurrentPlatform() {
    if (this.isSupportedOnCurrentPlatform === Maker.prototype.isSupportedOnCurrentPlatform) {
      throw new Error(`Maker ${this.name} did not implement the isSupportedOnCurrentPlatform method`);
    }

    return true;
  }
  /**
   * Makers must implement this method and return an array of absolute paths
   * to the artifacts generated by your maker
   */


  make(opts) {
    var _this = this;

    return _asyncToGenerator(function* () {
      if (_this.make === Maker.prototype.make) {
        throw new Error(`Maker ${_this.name} did not implement the make method`);
      }

      return [];
    })();
  }
  /**
   * Helpers
   */

  /**
   * Ensures the directory exists and is forced to be empty.
   *
   * I.e. If the directory already exists it is deleted and recreated, this
   * is a destructive operation
   */


  ensureDirectory(dir) {
    return _asyncToGenerator(function* () {
      if (yield _fsExtra.default.pathExists(dir)) {
        yield _fsExtra.default.remove(dir);
      }

      return _fsExtra.default.mkdirs(dir);
    })();
  }
  /**
   * Ensures the path to the file exists and the file does not exist
   *
   * I.e. If the file already exists it is deleted and the path created
   */


  ensureFile(file) {
    return _asyncToGenerator(function* () {
      if (yield _fsExtra.default.pathExists(file)) {
        yield _fsExtra.default.remove(file);
      }

      yield _fsExtra.default.mkdirs(_path.default.dirname(file));
    })();
  }
  /**
   * Checks if the given module is installed, used for testing if optional dependencies
   * are installed or not
   */


  isInstalled(module) {
    try {
      require(module);

      return true;
    } catch (e) {
      // Package doesn't exist -- must not be installable on this platform
      return false;
    }
  }

}

exports.default = Maker;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NYWtlci50cyJdLCJuYW1lcyI6WyJNYWtlciIsImNvbnN0cnVjdG9yIiwiY29uZmlnRmV0Y2hlciIsInByb3ZpZGVkUGxhdGZvcm1zIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJwbGF0Zm9ybXMiLCJkZWZhdWx0UGxhdGZvcm1zIiwicHJlcGFyZUNvbmZpZyIsInRhcmdldEFyY2giLCJjb25maWciLCJpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtIiwicHJvdG90eXBlIiwiRXJyb3IiLCJuYW1lIiwibWFrZSIsIm9wdHMiLCJlbnN1cmVEaXJlY3RvcnkiLCJkaXIiLCJmcyIsInBhdGhFeGlzdHMiLCJyZW1vdmUiLCJta2RpcnMiLCJlbnN1cmVGaWxlIiwiZmlsZSIsInBhdGgiLCJkaXJuYW1lIiwiaXNJbnN0YWxsZWQiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBR0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFrQ2UsTUFBZUEsS0FBZixDQUErQztBQUk1RDs7QUFFQTtBQUVBQyxFQUFBQSxXQUFXLENBQVNDLGFBQTZDLEdBQUcsRUFBekQsRUFBNEVDLGlCQUE1RSxFQUFpSDtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQzFIQyxJQUFBQSxNQUFNLENBQUNDLGNBQVAsQ0FBc0IsSUFBdEIsRUFBNEIsd0JBQTVCLEVBQXNEO0FBQ3BEQyxNQUFBQSxLQUFLLEVBQUUsSUFENkM7QUFFcERDLE1BQUFBLFVBQVUsRUFBRSxLQUZ3QztBQUdwREMsTUFBQUEsWUFBWSxFQUFFO0FBSHNDLEtBQXREO0FBS0Q7O0FBRUQsTUFBSUMsU0FBSixHQUFnQjtBQUNkLFFBQUksS0FBS04saUJBQVQsRUFBNEIsT0FBTyxLQUFLQSxpQkFBWjtBQUM1QixXQUFPLEtBQUtPLGdCQUFaO0FBQ0QsR0FuQjJELENBcUI1RDtBQUNBOzs7QUFDQUMsRUFBQUEsYUFBYSxDQUFDQyxVQUFELEVBQXdCO0FBQ25DLFFBQUksT0FBTyxLQUFLVixhQUFaLEtBQThCLFVBQWxDLEVBQThDO0FBQzVDLFdBQUtXLE1BQUwsR0FBZSxLQUFLWCxhQUFOLENBQXdEVSxVQUF4RCxDQUFkO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsV0FBS0MsTUFBTCxHQUFjLEtBQUtYLGFBQW5CO0FBQ0Q7QUFDRjtBQUVEOzs7Ozs7Ozs7OztBQVNBWSxFQUFBQSw0QkFBNEIsR0FBWTtBQUN0QyxRQUFJLEtBQUtBLDRCQUFMLEtBQXNDZCxLQUFLLENBQUNlLFNBQU4sQ0FBZ0JELDRCQUExRCxFQUF3RjtBQUN0RixZQUFNLElBQUlFLEtBQUosQ0FBVyxTQUFRLEtBQUtDLElBQUssNERBQTdCLENBQU47QUFDRDs7QUFDRCxXQUFPLElBQVA7QUFDRDtBQUVEOzs7Ozs7QUFJTUMsRUFBQUEsSUFBTixDQUFXQyxJQUFYLEVBQWtEO0FBQUE7O0FBQUE7QUFDaEQsVUFBSSxLQUFJLENBQUNELElBQUwsS0FBY2xCLEtBQUssQ0FBQ2UsU0FBTixDQUFnQkcsSUFBbEMsRUFBd0M7QUFDdEMsY0FBTSxJQUFJRixLQUFKLENBQVcsU0FBUSxLQUFJLENBQUNDLElBQUssb0NBQTdCLENBQU47QUFDRDs7QUFDRCxhQUFPLEVBQVA7QUFKZ0Q7QUFLakQ7QUFFRDs7OztBQUlBOzs7Ozs7OztBQU1NRyxFQUFBQSxlQUFOLENBQXNCQyxHQUF0QixFQUFrRDtBQUFBO0FBQ2hELGdCQUFVQyxpQkFBR0MsVUFBSCxDQUFjRixHQUFkLENBQVYsRUFBOEI7QUFDNUIsY0FBTUMsaUJBQUdFLE1BQUgsQ0FBVUgsR0FBVixDQUFOO0FBQ0Q7O0FBQ0QsYUFBT0MsaUJBQUdHLE1BQUgsQ0FBVUosR0FBVixDQUFQO0FBSmdEO0FBS2pEO0FBRUQ7Ozs7Ozs7QUFLTUssRUFBQUEsVUFBTixDQUFpQkMsSUFBakIsRUFBOEM7QUFBQTtBQUM1QyxnQkFBVUwsaUJBQUdDLFVBQUgsQ0FBY0ksSUFBZCxDQUFWLEVBQStCO0FBQzdCLGNBQU1MLGlCQUFHRSxNQUFILENBQVVHLElBQVYsQ0FBTjtBQUNEOztBQUNELFlBQU1MLGlCQUFHRyxNQUFILENBQVVHLGNBQUtDLE9BQUwsQ0FBYUYsSUFBYixDQUFWLENBQU47QUFKNEM7QUFLN0M7QUFFRDs7Ozs7O0FBSUFHLEVBQUFBLFdBQVcsQ0FBQ0MsTUFBRCxFQUEwQjtBQUNuQyxRQUFJO0FBQ0ZDLE1BQUFBLE9BQU8sQ0FBQ0QsTUFBRCxDQUFQOztBQUNBLGFBQU8sSUFBUDtBQUNELEtBSEQsQ0FHRSxPQUFPRSxDQUFQLEVBQVU7QUFDVjtBQUNBLGFBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBbkcyRCIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmltcG9ydCB7IEZvcmdlQXJjaCwgRm9yZ2VDb25maWcsIEZvcmdlUGxhdGZvcm0sIElGb3JnZU1ha2VyIH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL3NoYXJlZC10eXBlcyc7XG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFrZXJPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBkaXJlY3RvcnkgY29udGFpbmluZyB0aGUgcGFja2FnZWQgRWxlY3Ryb24gYXBwbGljYXRpb25cbiAgICovXG4gIGRpcjogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIGRpcmVjdG9yeSB5b3Ugc2hvdWxkIHB1dCBhbGwgeW91ciBhcnRpZmFjdHMgaW4gKHBvdGVudGlhbGx5IGluIHN1YiBmb2xkZXJzKVxuICAgKiBOT1RFOiB0aGlzIGRpcmVjdG9yeSBpcyBub3QgZ3VhcnVudGVlZCB0byBhbHJlYWR5IGV4aXN0XG4gICAqL1xuICBtYWtlRGlyOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcmVzb2x2ZWQgaHVtYW4gZnJpZW5kbHkgbmFtZSBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgYXBwTmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHRhcmdldCBwbGF0Zm9ybSB5b3Ugc2hvdWxkIG1ha2UgZm9yXG4gICAqL1xuICB0YXJnZXRQbGF0Zm9ybTogRm9yZ2VQbGF0Zm9ybTtcbiAgLyoqXG4gICAqIFRoZSB0YXJnZXQgYXJjaGl0ZWN0dXJlIHlvdSBzaG91bGQgbWFrZSBmb3JcbiAgICovXG4gIHRhcmdldEFyY2g6IEZvcmdlQXJjaDtcbiAgLyoqXG4gICAqIEZ1bGx5IHJlc29sdmVkIGZvcmdlIGNvbmZpZ3VyYXRpb24sIHlvdSBzaG91bGRuJ3QgcmVhbGx5IG5lZWQgdGhpc1xuICAgKi9cbiAgZm9yZ2VDb25maWc6IEZvcmdlQ29uZmlnO1xuICAvKipcbiAgICogVGhlIGFwcGxpY2F0aW9ucyBwYWNrYWdlLmpzb24gZmlsZVxuICAgKi9cbiAgcGFja2FnZUpTT046IGFueTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgTWFrZXI8Qz4gaW1wbGVtZW50cyBJRm9yZ2VNYWtlciB7XG4gIHB1YmxpYyBjb25maWchOiBDO1xuICBwdWJsaWMgYWJzdHJhY3QgbmFtZTogc3RyaW5nO1xuICBwdWJsaWMgYWJzdHJhY3QgZGVmYXVsdFBsYXRmb3JtczogRm9yZ2VQbGF0Zm9ybVtdO1xuICAvKiB0c2xpbnQ6ZGlzYWJsZSB2YXJpYWJsZS1uYW1lICovXG4gIF9faXNFbGVjdHJvbkZvcmdlTWFrZXIhOiB0cnVlO1xuICAvKiB0c2xpbnQ6ZW5hYmxlIHZhcmlhYmxlLW5hbWUgKi9cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbmZpZ0ZldGNoZXI6IChDIHwgKChhcmNoOiBGb3JnZUFyY2gpID0+IEMpKSA9IHt9IGFzIEMsIHByb3RlY3RlZCBwcm92aWRlZFBsYXRmb3Jtcz86IEZvcmdlUGxhdGZvcm1bXSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19pc0VsZWN0cm9uRm9yZ2VNYWtlcicsIHtcbiAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHBsYXRmb3JtcygpIHtcbiAgICBpZiAodGhpcy5wcm92aWRlZFBsYXRmb3JtcykgcmV0dXJuIHRoaXMucHJvdmlkZWRQbGF0Zm9ybXM7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdFBsYXRmb3JtcztcbiAgfVxuXG4gIC8vIFRPRE86IFJlbW92ZSB0aGlzLCBpdCBpcyBhbiBleWUtc29yZSBhbmQgaXMgYSBuYXN0eSBoYWNrIHRvIHByb3ZpZGUgZm9yZ2VcbiAgLy8gICAgICAgdjUgc3R5bGUgZnVuY3Rpb25hbGl0eSBpbiB0aGUgbmV3IEFQSVxuICBwcmVwYXJlQ29uZmlnKHRhcmdldEFyY2g6IEZvcmdlQXJjaCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5jb25maWdGZXRjaGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmNvbmZpZyA9ICh0aGlzLmNvbmZpZ0ZldGNoZXIgYXMgYW55IGFzICgoYXJjaDogRm9yZ2VBcmNoKSA9PiBDKSkodGFyZ2V0QXJjaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29uZmlnID0gdGhpcy5jb25maWdGZXRjaGVyIGFzIEM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VycyBtdXN0IGltcGxlbWVudCB0aGlzIG1ldGhvZCBhbmQgcmV0dXJuIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyXG4gICAqIHRoaXMgbWFrZXIgY2FuIGJlIHJ1biBvbiB0aGUgY3VycmVudCBwbGF0Zm9ybS4gIE5vcm1hbGx5IHRoaXMgaXMganVzdCBhIHByb2Nlc3MucGxhdGZvcm1cbiAgICogY2hlY2sgYnV0IGl0IGNhbiBiZSBhIGRlZXBlciBjaGVjayBmb3IgZGVwZW5kZW5jaWVzIGxpa2UgZmFrZS1yb290IG9yIG90aGVyXG4gICAqIHJlcXVpcmVkIGV4dGVybmFsIGJ1aWxkIHRvb2xzLlxuICAgKlxuICAgKiBJZiB0aGUgaXNzdWUgaXMgYSBtaXNzaW5nIGRlcGVuZGVuY3kgeW91IHNob3VsZCBsb2cgb3V0IGEgSEVMUEZVTCBlcnJvciBtZXNzYWdlXG4gICAqIHRlbGxpbmcgdGhlIGRldmVsb3BlciBleGFjdGx5IHdoYXQgaXMgbWlzc2luZyBhbmQgaWYgcG9zc2libGUgaG93IHRvIGdldCBpdC5cbiAgICovXG4gIGlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0oKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSA9PT0gTWFrZXIucHJvdG90eXBlLmlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWFrZXIgJHt0aGlzLm5hbWV9IGRpZCBub3QgaW1wbGVtZW50IHRoZSBpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtIG1ldGhvZGApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcnMgbXVzdCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgYW5kIHJldHVybiBhbiBhcnJheSBvZiBhYnNvbHV0ZSBwYXRoc1xuICAgKiB0byB0aGUgYXJ0aWZhY3RzIGdlbmVyYXRlZCBieSB5b3VyIG1ha2VyXG4gICAqL1xuICBhc3luYyBtYWtlKG9wdHM6IE1ha2VyT3B0aW9ucyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBpZiAodGhpcy5tYWtlID09PSBNYWtlci5wcm90b3R5cGUubWFrZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYWtlciAke3RoaXMubmFtZX0gZGlkIG5vdCBpbXBsZW1lbnQgdGhlIG1ha2UgbWV0aG9kYCk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXJzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoZSBkaXJlY3RvcnkgZXhpc3RzIGFuZCBpcyBmb3JjZWQgdG8gYmUgZW1wdHkuXG4gICAqXG4gICAqIEkuZS4gSWYgdGhlIGRpcmVjdG9yeSBhbHJlYWR5IGV4aXN0cyBpdCBpcyBkZWxldGVkIGFuZCByZWNyZWF0ZWQsIHRoaXNcbiAgICogaXMgYSBkZXN0cnVjdGl2ZSBvcGVyYXRpb25cbiAgICovXG4gIGFzeW5jIGVuc3VyZURpcmVjdG9yeShkaXI6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKGRpcikpIHtcbiAgICAgIGF3YWl0IGZzLnJlbW92ZShkaXIpO1xuICAgIH1cbiAgICByZXR1cm4gZnMubWtkaXJzKGRpcik7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlcyB0aGUgcGF0aCB0byB0aGUgZmlsZSBleGlzdHMgYW5kIHRoZSBmaWxlIGRvZXMgbm90IGV4aXN0XG4gICAqXG4gICAqIEkuZS4gSWYgdGhlIGZpbGUgYWxyZWFkeSBleGlzdHMgaXQgaXMgZGVsZXRlZCBhbmQgdGhlIHBhdGggY3JlYXRlZFxuICAgKi9cbiAgYXN5bmMgZW5zdXJlRmlsZShmaWxlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhmaWxlKSkge1xuICAgICAgYXdhaXQgZnMucmVtb3ZlKGZpbGUpO1xuICAgIH1cbiAgICBhd2FpdCBmcy5ta2RpcnMocGF0aC5kaXJuYW1lKGZpbGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIG1vZHVsZSBpcyBpbnN0YWxsZWQsIHVzZWQgZm9yIHRlc3RpbmcgaWYgb3B0aW9uYWwgZGVwZW5kZW5jaWVzXG4gICAqIGFyZSBpbnN0YWxsZWQgb3Igbm90XG4gICAqL1xuICBpc0luc3RhbGxlZChtb2R1bGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICByZXF1aXJlKG1vZHVsZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBQYWNrYWdlIGRvZXNuJ3QgZXhpc3QgLS0gbXVzdCBub3QgYmUgaW5zdGFsbGFibGUgb24gdGhpcyBwbGF0Zm9ybVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuIl19