"use strict";

require("source-map-support/register");

var _core = require("@electron-forge/core");

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _commander = _interopRequireDefault(require("commander"));

require("./util/terminate");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

_asyncToGenerator(function* () {
  let commandArgs = process.argv;
  let appArgs;
  const doubleDashIndex = process.argv.indexOf('--');

  if (doubleDashIndex !== -1) {
    commandArgs = process.argv.slice(0, doubleDashIndex);
    appArgs = process.argv.slice(doubleDashIndex + 1);
  }

  let dir = process.cwd();

  _commander.default.version(require('../package.json').version).arguments('[cwd]').option('-p, --app-path <path>', 'Override the path to the Electron app to launch (defaults to \'.\')').option('-l, --enable-logging', 'Enable advanced logging.  This will log internal Electron things').option('-n, --run-as-node', 'Run the Electron app as a Node.JS script').option('--vscode', 'Used to enable arg transformation for debugging Electron through VSCode.  Do not use yourself.').option('-i, --inspect-electron', 'Triggers inspect mode on Electron to allow debugging the main process.  Electron >1.7 only').action(cwd => {
    if (!cwd) return;

    if (_path.default.isAbsolute(cwd) && _fsExtra.default.existsSync(cwd)) {
      dir = cwd;
    } else if (_fsExtra.default.existsSync(_path.default.resolve(dir, cwd))) {
      dir = _path.default.resolve(dir, cwd);
    }
  }).parse(commandArgs);

  _commander.default.on('--help', () => {
    console.log('  Any arguments found after "--" will be passed to the Electron app, e.g.');
    console.log('');
    console.log('    $ electron-forge /path/to/project -l -- -d -f foo.txt');
    console.log('');
    console.log('  will pass the arguments "-d -f foo.txt" to the Electron app');
  });

  const opts = {
    dir,
    interactive: true,
    enableLogging: !!_commander.default.enableLogging,
    runAsNode: !!_commander.default.runAsNode,
    inspect: !!_commander.default.inspectElectron
  };

  if (_commander.default.vscode && appArgs) {
    // Args are in the format ~arg~ so we need to strip the "~"
    appArgs = appArgs.map(arg => arg.substr(1, arg.length - 2)).filter(arg => arg.length > 0);
  }

  if (_commander.default.appPath) opts.appPath = _commander.default.appPath;
  if (appArgs) opts.args = appArgs;
  const spawned = yield _core.api.start(opts);
  yield new Promise(resolve => {
    const listenForExit = child => {
      const removeListeners = () => {
        child.removeListener('exit', onExit);
        child.removeListener('restarted', onRestart);
      };

      const onExit = code => {
        removeListeners();
        if (spawned.restarted) return;

        if (code !== 0) {
          process.exit(code);
        }

        resolve();
      };

      const onRestart = newChild => {
        removeListeners();
        listenForExit(newChild);
      };

      child.on('exit', onExit);
      child.on('restarted', onRestart);
    };

    listenForExit(spawned);
  });
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9lbGVjdHJvbi1mb3JnZS1zdGFydC50cyJdLCJuYW1lcyI6WyJjb21tYW5kQXJncyIsInByb2Nlc3MiLCJhcmd2IiwiYXBwQXJncyIsImRvdWJsZURhc2hJbmRleCIsImluZGV4T2YiLCJzbGljZSIsImRpciIsImN3ZCIsInByb2dyYW0iLCJ2ZXJzaW9uIiwicmVxdWlyZSIsImFyZ3VtZW50cyIsIm9wdGlvbiIsImFjdGlvbiIsInBhdGgiLCJpc0Fic29sdXRlIiwiZnMiLCJleGlzdHNTeW5jIiwicmVzb2x2ZSIsInBhcnNlIiwib24iLCJjb25zb2xlIiwibG9nIiwib3B0cyIsImludGVyYWN0aXZlIiwiZW5hYmxlTG9nZ2luZyIsInJ1bkFzTm9kZSIsImluc3BlY3QiLCJpbnNwZWN0RWxlY3Ryb24iLCJ2c2NvZGUiLCJtYXAiLCJhcmciLCJzdWJzdHIiLCJsZW5ndGgiLCJmaWx0ZXIiLCJhcHBQYXRoIiwiYXJncyIsInNwYXduZWQiLCJhcGkiLCJzdGFydCIsIlByb21pc2UiLCJsaXN0ZW5Gb3JFeGl0IiwiY2hpbGQiLCJyZW1vdmVMaXN0ZW5lcnMiLCJyZW1vdmVMaXN0ZW5lciIsIm9uRXhpdCIsIm9uUmVzdGFydCIsImNvZGUiLCJyZXN0YXJ0ZWQiLCJleGl0IiwibmV3Q2hpbGQiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFHQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7QUFFQSxrQkFBQyxhQUFZO0FBQ1gsTUFBSUEsV0FBVyxHQUFHQyxPQUFPLENBQUNDLElBQTFCO0FBQ0EsTUFBSUMsT0FBSjtBQUVBLFFBQU1DLGVBQWUsR0FBR0gsT0FBTyxDQUFDQyxJQUFSLENBQWFHLE9BQWIsQ0FBcUIsSUFBckIsQ0FBeEI7O0FBQ0EsTUFBSUQsZUFBZSxLQUFLLENBQUMsQ0FBekIsRUFBNEI7QUFDMUJKLElBQUFBLFdBQVcsR0FBR0MsT0FBTyxDQUFDQyxJQUFSLENBQWFJLEtBQWIsQ0FBbUIsQ0FBbkIsRUFBc0JGLGVBQXRCLENBQWQ7QUFD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cUIsV0FBckIsRUFBa0NFLFNBQWxDO0FBQ0QsT0FIRDs7QUFJQSxZQUFNRCxNQUFNLEdBQUlFLElBQUQsSUFBa0I7QUFDL0JKLFFBQUFBLGVBQWU7QUFDZixZQUFLTixPQUFELENBQWlCVyxTQUFyQixFQUFnQzs7QUFDaEMsWUFBSUQsSUFBSSxLQUFLLENBQWIsRUFBZ0I7QUFDZC9DLFVBQUFBLE9BQU8sQ0FBQ2lELElBQVIsQ0FBYUYsSUFBYjtBQUNEOztBQUNEN0IsUUFBQUEsT0FBTztBQUNSLE9BUEQ7O0FBUUEsWUFBTTRCLFNBQVMsR0FBSUksUUFBRCxJQUE0QjtBQUM1Q1AsUUFBQUEsZUFBZTtBQUNmRixRQUFBQSxhQUFhLENBQUNTLFFBQUQsQ0FBYjtBQUNELE9BSEQ7O0FBSUFSLE1BQUFBLEtBQUssQ0FBQ3RCLEVBQU4sQ0FBUyxNQUFULEVBQWlCeUIsTUFBakI7QUFDQUgsTUFBQUEsS0FBSyxDQUFDdEIsRUFBTixDQUFTLFdBQVQsRUFBc0IwQixTQUF0QjtBQUNELEtBbkJEOztBQW9CQUwsSUFBQUEsYUFBYSxDQUFDSixPQUFELENBQWI7QUFDRCxHQXRCSyxDQUFOO0FBdUJELENBaEZEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBpLCBTdGFydE9wdGlvbnMgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvY29yZSc7XG5cbmltcG9ydCB7IENoaWxkUHJvY2VzcyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHByb2dyYW0gZnJvbSAnY29tbWFuZGVyJztcblxuaW1wb3J0ICcuL3V0aWwvdGVybWluYXRlJztcblxuKGFzeW5jICgpID0+IHtcbiAgbGV0IGNvbW1hbmRBcmdzID0gcHJvY2Vzcy5hcmd2O1xuICBsZXQgYXBwQXJncztcblxuICBjb25zdCBkb3VibGVEYXNoSW5kZXggPSBwcm9jZXNzLmFyZ3YuaW5kZXhPZignLS0nKTtcbiAgaWYgKGRvdWJsZURhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBjb21tYW5kQXJncyA9IHByb2Nlc3MuYXJndi5zbGljZSgwLCBkb3VibGVEYXNoSW5kZXgpO1xuICAgIGFwcEFyZ3MgPSBwcm9jZXNzLmFyZ3Yuc2xpY2UoZG91YmxlRGFzaEluZGV4ICsgMSk7XG4gIH1cblxuICBsZXQgZGlyID0gcHJvY2Vzcy5jd2QoKTtcbiAgcHJvZ3JhbVxuICAgIC52ZXJzaW9uKHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb24pXG4gICAgLmFyZ3VtZW50cygnW2N3ZF0nKVxuICAgIC5vcHRpb24oJy1wLCAtLWFwcC1wYXRoIDxwYXRoPicsICdPdmVycmlkZSB0aGUgcGF0aCB0byB0aGUgRWxlY3Ryb24gYXBwIHRvIGxhdW5jaCAoZGVmYXVsdHMgdG8gXFwnLlxcJyknKVxuICAgIC5vcHRpb24oJy1sLCAtLWVuYWJsZS1sb2dnaW5nJywgJ0VuYWJsZSBhZHZhbmNlZCBsb2dnaW5nLiAgVGhpcyB3aWxsIGxvZyBpbnRlcm5hbCBFbGVjdHJvbiB0aGluZ3MnKVxuICAgIC5vcHRpb24oJy1uLCAtLXJ1bi1hcy1ub2RlJywgJ1J1biB0aGUgRWxlY3Ryb24gYXBwIGFzIGEgTm9kZS5KUyBzY3JpcHQnKVxuICAgIC5vcHRpb24oJy0tdnNjb2RlJywgJ1VzZWQgdG8gZW5hYmxlIGFyZyB0cmFuc2Zvcm1hdGlvbiBmb3IgZGVidWdnaW5nIEVsZWN0cm9uIHRocm91Z2ggVlNDb2RlLiAgRG8gbm90IHVzZSB5b3Vyc2VsZi4nKVxuICAgIC5vcHRpb24oJy1pLCAtLWluc3BlY3QtZWxlY3Ryb24nLCAnVHJpZ2dlcnMgaW5zcGVjdCBtb2RlIG9uIEVsZWN0cm9uIHRvIGFsbG93IGRlYnVnZ2luZyB0aGUgbWFpbiBwcm9jZXNzLiAgRWxlY3Ryb24gPjEuNyBvbmx5JylcbiAgICAuYWN0aW9uKChjd2QpID0+IHtcbiAgICAgIGlmICghY3dkKSByZXR1cm47XG4gICAgICBpZiAocGF0aC5pc0Fic29sdXRlKGN3ZCkgJiYgZnMuZXhpc3RzU3luYyhjd2QpKSB7XG4gICAgICAgIGRpciA9IGN3ZDtcbiAgICAgIH0gZWxzZSBpZiAoZnMuZXhpc3RzU3luYyhwYXRoLnJlc29sdmUoZGlyLCBjd2QpKSkge1xuICAgICAgICBkaXIgPSBwYXRoLnJlc29sdmUoZGlyLCBjd2QpO1xuICAgICAgfVxuICAgIH0pXG4gICAgLnBhcnNlKGNvbW1hbmRBcmdzKTtcblxuICBwcm9ncmFtLm9uKCctLWhlbHAnLCAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJyAgQW55IGFyZ3VtZW50cyBmb3VuZCBhZnRlciBcIi0tXCIgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIEVsZWN0cm9uIGFwcCwgZS5nLicpO1xuICAgIGNvbnNvbGUubG9nKCcnKTtcbiAgICBjb25zb2xlLmxvZygnICAgICQgZWxlY3Ryb24tZm9yZ2UgL3BhdGgvdG8vcHJvamVjdCAtbCAtLSAtZCAtZiBmb28udHh0Jyk7XG4gICAgY29uc29sZS5sb2coJycpO1xuICAgIGNvbnNvbGUubG9nKCcgIHdpbGwgcGFzcyB0aGUgYXJndW1lbnRzIFwiLWQgLWYgZm9vLnR4dFwiIHRvIHRoZSBFbGVjdHJvbiBhcHAnKTtcbiAgfSk7XG5cbiAgY29uc3Qgb3B0czogU3RhcnRPcHRpb25zID0ge1xuICAgIGRpcixcbiAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICBlbmFibGVMb2dnaW5nOiAhIXByb2dyYW0uZW5hYmxlTG9nZ2luZyxcbiAgICBydW5Bc05vZGU6ICEhcHJvZ3JhbS5ydW5Bc05vZGUsXG4gICAgaW5zcGVjdDogISFwcm9ncmFtLmluc3BlY3RFbGVjdHJvbixcbiAgfTtcblxuICBpZiAocHJvZ3JhbS52c2NvZGUgJiYgYXBwQXJncykge1xuICAgIC8vIEFyZ3MgYXJlIGluIHRoZSBmb3JtYXQgfmFyZ34gc28gd2UgbmVlZCB0byBzdHJpcCB0aGUgXCJ+XCJcbiAgICBhcHBBcmdzID0gYXBwQXJnc1xuICAgICAgLm1hcChhcmcgPT4gYXJnLnN1YnN0cigxLCBhcmcubGVuZ3RoIC0gMikpXG4gICAgICAuZmlsdGVyKGFyZyA9PiBhcmcubGVuZ3RoID4gMCk7XG4gIH1cblxuICBpZiAocHJvZ3JhbS5hcHBQYXRoKSBvcHRzLmFwcFBhdGggPSBwcm9ncmFtLmFwcFBhdGg7XG4gIGlmIChhcHBBcmdzKSBvcHRzLmFyZ3MgPSBhcHBBcmdzO1xuXG4gIGNvbnN0IHNwYXduZWQgPSBhd2FpdCBhcGkuc3RhcnQob3B0cyk7XG5cbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBsaXN0ZW5Gb3JFeGl0ID0gKGNoaWxkOiBDaGlsZFByb2Nlc3MpID0+IHtcbiAgICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgICAgY2hpbGQucmVtb3ZlTGlzdGVuZXIoJ2V4aXQnLCBvbkV4aXQpO1xuICAgICAgICBjaGlsZC5yZW1vdmVMaXN0ZW5lcigncmVzdGFydGVkJywgb25SZXN0YXJ0KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBvbkV4aXQgPSAoY29kZTogbnVtYmVyKSA9PiB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICBpZiAoKHNwYXduZWQgYXMgYW55KS5yZXN0YXJ0ZWQpIHJldHVybjtcbiAgICAgICAgaWYgKGNvZGUgIT09IDApIHtcbiAgICAgICAgICBwcm9jZXNzLmV4aXQoY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9uUmVzdGFydCA9IChuZXdDaGlsZDogQ2hpbGRQcm9jZXNzKSA9PiB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICBsaXN0ZW5Gb3JFeGl0KG5ld0NoaWxkKTtcbiAgICAgIH07XG4gICAgICBjaGlsZC5vbignZXhpdCcsIG9uRXhpdCk7XG4gICAgICBjaGlsZC5vbigncmVzdGFydGVkJywgb25SZXN0YXJ0KTtcbiAgICB9O1xuICAgIGxpc3RlbkZvckV4aXQoc3Bhd25lZCk7XG4gIH0pO1xufSkoKTtcbiJdfQ==