"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validPackageManagerVersion = validPackageManagerVersion;
exports.default = _default;

require("source-map-support/register");

var _child_process = require("child_process");

var _debug = _interopRequireDefault(require("debug"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _semver = _interopRequireDefault(require("semver"));

var _core = require("@electron-forge/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const d = (0, _debug.default)('electron-forge:check-system');

function checkGitExists() {
  return _checkGitExists.apply(this, arguments);
}

function _checkGitExists() {
  _checkGitExists = _asyncToGenerator(function* () {
    return new Promise(resolve => {
      (0, _child_process.exec)('git --version', err => {
        if (err) return resolve(false);
        resolve(true);
      });
    });
  });
  return _checkGitExists.apply(this, arguments);
}

function checkNodeVersion() {
  return _checkNodeVersion.apply(this, arguments);
}

function _checkNodeVersion() {
  _checkNodeVersion = _asyncToGenerator(function* () {
    return Promise.resolve(_semver.default.gt(process.versions.node, '6.0.0'));
  });
  return _checkNodeVersion.apply(this, arguments);
}

const NPM_WHITELISTED_VERSIONS = {
  all: '^3.0.0 || ^4.0.0 || ~5.1.0 || ~5.2.0 || >= 5.4.2',
  darwin: '>= 5.4.0',
  linux: '>= 5.4.0'
};
const YARN_WHITELISTED_VERSIONS = {
  all: '0.23.3 || 0.24.6 || >= 1.0.0',
  darwin: '0.27.5',
  linux: '0.27.5'
};

function validPackageManagerVersion(packageManager, version, whitelistedVersions, ora) {
  try {
    return _semver.default.satisfies(version, whitelistedVersions);
  } catch (e) {
    ora.warn(`Could not check ${packageManager} version "${version}", assuming incompatible`);
    d(`Exception while checking version: ${e}`);
    return false;
  }
}

function warnIfPackageManagerIsntAKnownGoodVersion(packageManager, version, whitelistedVersions, ora) {
  const osVersions = whitelistedVersions[process.platform];
  const versions = osVersions ? `${whitelistedVersions.all} || ${osVersions}` : whitelistedVersions.all;
  const versionString = version.toString();

  if (!validPackageManagerVersion(packageManager, versionString, versions, ora)) {
    ora.warn(`You are using ${packageManager}, but not a known good version.
The known versions that work with Electron Forge are: ${versions}`);
  }
}

function checkPackageManagerVersion(_x) {
  return _checkPackageManagerVersion.apply(this, arguments);
}
/**
 * Some people know their system is OK and don't appreciate the 800ms lag in
 * start up that these checks (in particular the package manager check) costs.
 *
 * Simply creating this flag file in your home directory will skip these checks
 * and shave ~800ms off your forge start time.
 *
 * This is specifically not documented or everyone would make it.
 */


function _checkPackageManagerVersion() {
  _checkPackageManagerVersion = _asyncToGenerator(function* (ora) {
    return _core.utils.yarnOrNpmSpawn(['--version']).then(version => {
      const versionString = version.toString();

      if (_core.utils.hasYarn()) {
        warnIfPackageManagerIsntAKnownGoodVersion('Yarn', versionString, YARN_WHITELISTED_VERSIONS, ora);
      } else {
        warnIfPackageManagerIsntAKnownGoodVersion('NPM', versionString, NPM_WHITELISTED_VERSIONS, ora);
      }

      return true;
    });
  });
  return _checkPackageManagerVersion.apply(this, arguments);
}

const SKIP_SYSTEM_CHECK = _path.default.resolve(_os.default.homedir(), '.skip-forge-system-check');

function _default(_x2) {
  return _ref.apply(this, arguments);
}

function _ref() {
  _ref = _asyncToGenerator(function* (ora) {
    if (!(yield _fsExtra.default.pathExists(SKIP_SYSTEM_CHECK))) {
      d('checking system, create ~/.skip-forge-system-check to stop doing this');
      return (yield Promise.all([checkGitExists(), checkNodeVersion(), checkPackageManagerVersion(ora)])).every(check => check);
    }

    d('skipping system check');
    return true;
  });
  return _ref.apply(this, arguments);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2NoZWNrLXN5c3RlbS50cyJdLCJuYW1lcyI6WyJkIiwiY2hlY2tHaXRFeGlzdHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsImVyciIsImNoZWNrTm9kZVZlcnNpb24iLCJzZW12ZXIiLCJndCIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm5vZGUiLCJOUE1fV0hJVEVMSVNURURfVkVSU0lPTlMiLCJhbGwiLCJkYXJ3aW4iLCJsaW51eCIsIllBUk5fV0hJVEVMSVNURURfVkVSU0lPTlMiLCJ2YWxpZFBhY2thZ2VNYW5hZ2VyVmVyc2lvbiIsInBhY2thZ2VNYW5hZ2VyIiwidmVyc2lvbiIsIndoaXRlbGlzdGVkVmVyc2lvbnMiLCJvcmEiLCJzYXRpc2ZpZXMiLCJlIiwid2FybiIsIndhcm5JZlBhY2thZ2VNYW5hZ2VySXNudEFLbm93bkdvb2RWZXJzaW9uIiwib3NWZXJzaW9ucyIsInBsYXRmb3JtIiwidmVyc2lvblN0cmluZyIsInRvU3RyaW5nIiwiY2hlY2tQYWNrYWdlTWFuYWdlclZlcnNpb24iLCJmb3JnZVV0aWxzIiwieWFybk9yTnBtU3Bhd24iLCJ0aGVuIiwiaGFzWWFybiIsIlNLSVBfU1lTVEVNX0NIRUNLIiwicGF0aCIsIm9zIiwiaG9tZWRpciIsImZzIiwicGF0aEV4aXN0cyIsImV2ZXJ5IiwiY2hlY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7QUFHQSxNQUFNQSxDQUFDLEdBQUcsb0JBQU0sNkJBQU4sQ0FBVjs7U0FFZUMsYzs7Ozs7c0NBQWYsYUFBZ0M7QUFDOUIsV0FBTyxJQUFJQyxPQUFKLENBQXNCQyxPQUFELElBQWE7QUFDdkMsK0JBQUssZUFBTCxFQUF1QkMsR0FBRCxJQUFTO0FBQzdCLFlBQUlBLEdBQUosRUFBUyxPQUFPRCxPQUFPLENBQUMsS0FBRCxDQUFkO0FBQ1RBLFFBQUFBLE9BQU8sQ0FBQyxJQUFELENBQVA7QUFDRCxP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LEdBQVIsQ0FBWSxDQUFDWCxjQUFjLEVBQWYsRUFBbUJJLGdCQUFnQixFQUFuQyxFQUF1Q3dCLDBCQUEwQixDQUFDVCxHQUFELENBQWpFLENBQVosQ0FBUCxFQUNKb0IsS0FESSxDQUNFQyxLQUFLLElBQUlBLEtBRFgsQ0FBUDtBQUVEOztBQUNEekMsSUFBQUEsQ0FBQyxDQUFDLHVCQUFELENBQUQ7QUFDQSxXQUFPLElBQVA7QUFDRCxHIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhlYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgb3MgZnJvbSAnb3MnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5cbmltcG9ydCB7IHV0aWxzIGFzIGZvcmdlVXRpbHMgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvY29yZSc7XG5pbXBvcnQgeyBPcmFJbXBsIH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL2FzeW5jLW9yYSc7XG5cbmNvbnN0IGQgPSBkZWJ1ZygnZWxlY3Ryb24tZm9yZ2U6Y2hlY2stc3lzdGVtJyk7XG5cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrR2l0RXhpc3RzKCkge1xuICByZXR1cm4gbmV3IFByb21pc2U8Ym9vbGVhbj4oKHJlc29sdmUpID0+IHtcbiAgICBleGVjKCdnaXQgLS12ZXJzaW9uJywgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlc29sdmUoZmFsc2UpO1xuICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrTm9kZVZlcnNpb24oKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2VtdmVyLmd0KHByb2Nlc3MudmVyc2lvbnMubm9kZSwgJzYuMC4wJykpO1xufVxuXG5jb25zdCBOUE1fV0hJVEVMSVNURURfVkVSU0lPTlMgPSB7XG4gIGFsbDogJ14zLjAuMCB8fCBeNC4wLjAgfHwgfjUuMS4wIHx8IH41LjIuMCB8fCA+PSA1LjQuMicsXG4gIGRhcndpbjogJz49IDUuNC4wJyxcbiAgbGludXg6ICc+PSA1LjQuMCcsXG59O1xuY29uc3QgWUFSTl9XSElURUxJU1RFRF9WRVJTSU9OUyA9IHtcbiAgYWxsOiAnMC4yMy4zIHx8IDAuMjQuNiB8fCA+PSAxLjAuMCcsXG4gIGRhcndpbjogJzAuMjcuNScsXG4gIGxpbnV4OiAnMC4yNy41Jyxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZFBhY2thZ2VNYW5hZ2VyVmVyc2lvbihwYWNrYWdlTWFuYWdlcjogc3RyaW5nLCB2ZXJzaW9uOiBzdHJpbmcsIHdoaXRlbGlzdGVkVmVyc2lvbnM6IHN0cmluZywgb3JhOiBPcmFJbXBsKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHNlbXZlci5zYXRpc2ZpZXModmVyc2lvbiwgd2hpdGVsaXN0ZWRWZXJzaW9ucyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBvcmEud2FybiEoYENvdWxkIG5vdCBjaGVjayAke3BhY2thZ2VNYW5hZ2VyfSB2ZXJzaW9uIFwiJHt2ZXJzaW9ufVwiLCBhc3N1bWluZyBpbmNvbXBhdGlibGVgKTtcbiAgICBkKGBFeGNlcHRpb24gd2hpbGUgY2hlY2tpbmcgdmVyc2lvbjogJHtlfWApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuSWZQYWNrYWdlTWFuYWdlcklzbnRBS25vd25Hb29kVmVyc2lvbihwYWNrYWdlTWFuYWdlcjogc3RyaW5nLCB2ZXJzaW9uOiBzdHJpbmcsIHdoaXRlbGlzdGVkVmVyc2lvbnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sIG9yYTogT3JhSW1wbCkge1xuICBjb25zdCBvc1ZlcnNpb25zID0gd2hpdGVsaXN0ZWRWZXJzaW9uc1twcm9jZXNzLnBsYXRmb3JtXTtcbiAgY29uc3QgdmVyc2lvbnMgPSBvc1ZlcnNpb25zID8gYCR7d2hpdGVsaXN0ZWRWZXJzaW9ucy5hbGx9IHx8ICR7b3NWZXJzaW9uc31gIDogd2hpdGVsaXN0ZWRWZXJzaW9ucy5hbGw7XG4gIGNvbnN0IHZlcnNpb25TdHJpbmcgPSB2ZXJzaW9uLnRvU3RyaW5nKCk7XG4gIGlmICghdmFsaWRQYWNrYWdlTWFuYWdlclZlcnNpb24ocGFja2FnZU1hbmFnZXIsIHZlcnNpb25TdHJpbmcsIHZlcnNpb25zLCBvcmEpKSB7XG4gICAgb3JhLndhcm4hKGBZb3UgYXJlIHVzaW5nICR7cGFja2FnZU1hbmFnZXJ9LCBidXQgbm90IGEga25vd24gZ29vZCB2ZXJzaW9uLlxuVGhlIGtub3duIHZlcnNpb25zIHRoYXQgd29yayB3aXRoIEVsZWN0cm9uIEZvcmdlIGFyZTogJHt2ZXJzaW9uc31gKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjaGVja1BhY2thZ2VNYW5hZ2VyVmVyc2lvbihvcmE6IE9yYUltcGwpIHtcbiAgcmV0dXJuIGZvcmdlVXRpbHMueWFybk9yTnBtU3Bhd24oWyctLXZlcnNpb24nXSlcbiAgICAudGhlbigodmVyc2lvbikgPT4ge1xuICAgICAgY29uc3QgdmVyc2lvblN0cmluZyA9IHZlcnNpb24udG9TdHJpbmcoKTtcbiAgICAgIGlmIChmb3JnZVV0aWxzLmhhc1lhcm4oKSkge1xuICAgICAgICB3YXJuSWZQYWNrYWdlTWFuYWdlcklzbnRBS25vd25Hb29kVmVyc2lvbignWWFybicsIHZlcnNpb25TdHJpbmcsIFlBUk5fV0hJVEVMSVNURURfVkVSU0lPTlMsIG9yYSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuSWZQYWNrYWdlTWFuYWdlcklzbnRBS25vd25Hb29kVmVyc2lvbignTlBNJywgdmVyc2lvblN0cmluZywgTlBNX1dISVRFTElTVEVEX1ZFUlNJT05TLCBvcmEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBTb21lIHBlb3BsZSBrbm93IHRoZWlyIHN5c3RlbSBpcyBPSyBhbmQgZG9uJ3QgYXBwcmVjaWF0ZSB0aGUgODAwbXMgbGFnIGluXG4gKiBzdGFydCB1cCB0aGF0IHRoZXNlIGNoZWNrcyAoaW4gcGFydGljdWxhciB0aGUgcGFja2FnZSBtYW5hZ2VyIGNoZWNrKSBjb3N0cy5cbiAqXG4gKiBTaW1wbHkgY3JlYXRpbmcgdGhpcyBmbGFnIGZpbGUgaW4geW91ciBob21lIGRpcmVjdG9yeSB3aWxsIHNraXAgdGhlc2UgY2hlY2tzXG4gKiBhbmQgc2hhdmUgfjgwMG1zIG9mZiB5b3VyIGZvcmdlIHN0YXJ0IHRpbWUuXG4gKlxuICogVGhpcyBpcyBzcGVjaWZpY2FsbHkgbm90IGRvY3VtZW50ZWQgb3IgZXZlcnlvbmUgd291bGQgbWFrZSBpdC5cbiAqL1xuY29uc3QgU0tJUF9TWVNURU1fQ0hFQ0sgPSBwYXRoLnJlc29sdmUob3MuaG9tZWRpcigpLCAnLnNraXAtZm9yZ2Utc3lzdGVtLWNoZWNrJyk7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIChvcmE6IE9yYUltcGwpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgaWYgKCFhd2FpdCBmcy5wYXRoRXhpc3RzKFNLSVBfU1lTVEVNX0NIRUNLKSkge1xuICAgIGQoJ2NoZWNraW5nIHN5c3RlbSwgY3JlYXRlIH4vLnNraXAtZm9yZ2Utc3lzdGVtLWNoZWNrIHRvIHN0b3AgZG9pbmcgdGhpcycpO1xuICAgIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoW2NoZWNrR2l0RXhpc3RzKCksIGNoZWNrTm9kZVZlcnNpb24oKSwgY2hlY2tQYWNrYWdlTWFuYWdlclZlcnNpb24ob3JhKV0pKVxuICAgICAgLmV2ZXJ5KGNoZWNrID0+IGNoZWNrKTtcbiAgfVxuICBkKCdza2lwcGluZyBzeXN0ZW0gY2hlY2snKTtcbiAgcmV0dXJuIHRydWU7XG59XG4iXX0=