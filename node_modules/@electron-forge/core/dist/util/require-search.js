"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.requireSearchRaw = requireSearchRaw;
exports.default = void 0;

require("source-map-support/register");

var _debug = _interopRequireDefault(require("debug"));

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug.default)('electron-forge:require-search');

function requireSearchRaw(relativeTo, paths) {
  const testPaths = paths.concat(paths.map(mapPath => _path.default.resolve(relativeTo, mapPath))).concat(paths.map(mapPath => _path.default.resolve(relativeTo, 'node_modules', mapPath)));
  d('searching', testPaths, 'relative to', relativeTo);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = testPaths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      const testPath = _step.value;

      try {
        d('testing', testPath);
        return require(testPath);
      } catch (err) {// Ignore the error
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  d('failed to find a module in', testPaths);
  return null;
}

var _default = (relativeTo, paths) => {
  const result = requireSearchRaw(relativeTo, paths);
  return typeof result === 'object' && result && result.default ? result.default : result;
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL3JlcXVpcmUtc2VhcmNoLnRzIl0sIm5hbWVzIjpbImQiLCJyZXF1aXJlU2VhcmNoUmF3IiwicmVsYXRpdmVUbyIsInBhdGhzIiwidGVzdFBhdGhzIiwiY29uY2F0IiwibWFwIiwibWFwUGF0aCIsInBhdGgiLCJyZXNvbHZlIiwidGVzdFBhdGgiLCJyZXF1aXJlIiwiZXJyIiwicmVzdWx0IiwiZGVmYXVsdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOztBQUNBOzs7O0FBRUEsTUFBTUEsQ0FBQyxHQUFHLG9CQUFNLCtCQUFOLENBQVY7O0FBRU8sU0FBU0MsZ0JBQVQsQ0FBNkJDLFVBQTdCLEVBQWlEQyxLQUFqRCxFQUE0RTtBQUNqRixRQUFNQyxTQUFTLEdBQUdELEtBQUssQ0FDcEJFLE1BRGUsQ0FDUkYsS0FBSyxDQUFDRyxHQUFOLENBQVVDLE9BQU8sSUFBSUMsY0FBS0MsT0FBTCxDQUFhUCxVQUFiLEVBQXlCSyxPQUF6QixDQUFyQixDQURRLEVBRWZGLE1BRmUsQ0FFUkYsS0FBSyxDQUFDRyxHQUFOLENBQVVDLE9BQU8sSUFBSUMsY0FBS0MsT0FBTCxDQUFhUCxVQUFiLEVBQXlCLGNBQXpCLEVBQXlDSyxPQUF6QyxDQUFyQixDQUZRLENBQWxCO0FBR0FQLEVBQUFBLENBQUMsQ0FBQyxXQUFELEVBQWNJLFNBQWQsRUFBeUIsYUFBekIsRUFBd0NGLFVBQXhDLENBQUQ7QUFKaUY7QUFBQTtBQUFBOztBQUFBO0FBS2pGLHlCQUF1QkUsU0FBdkIsOEhBQWtDO0FBQUEsWUFBdkJNLFFBQXVCOztBQUNoQyxVQUFJO0FBQ0ZWLFFBQUFBLENBQUMsQ0FBQyxTQUFELEVBQVlVLFFBQVosQ0FBRDtBQUNBLGVBQU9DLE9BQU8sQ0FBQ0QsUUFBRCxDQUFkO0FBQ0QsT0FIRCxDQUdFLE9BQU9FLEdBQVAsRUFBWSxDQUNaO0FBQ0Q7QUFDRjtBQVpnRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWFqRlosRUFBQUEsQ0FBQyxDQUFDLDRCQUFELEVBQStCSSxTQUEvQixDQUFEO0FBQ0EsU0FBTyxJQUFQO0FBQ0Q7O2VBTWUsQ0FBR0YsVUFBSCxFQUF1QkMsS0FBdkIsS0FBcUQ7QUFDbkUsUUFBTVUsTUFBTSxHQUFHWixnQkFBZ0IsQ0FBb0JDLFVBQXBCLEVBQWdDQyxLQUFoQyxDQUEvQjtBQUNBLFNBQU8sT0FBT1UsTUFBUCxLQUFrQixRQUFsQixJQUE4QkEsTUFBOUIsSUFBd0NBLE1BQU0sQ0FBQ0MsT0FBL0MsR0FBeURELE1BQU0sQ0FBQ0MsT0FBaEUsR0FBMEVELE1BQWpGO0FBQ0QsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuY29uc3QgZCA9IGRlYnVnKCdlbGVjdHJvbi1mb3JnZTpyZXF1aXJlLXNlYXJjaCcpO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZVNlYXJjaFJhdzxUPihyZWxhdGl2ZVRvOiBzdHJpbmcsIHBhdGhzOiBzdHJpbmdbXSk6IFQgfCBudWxsIHtcbiAgY29uc3QgdGVzdFBhdGhzID0gcGF0aHNcbiAgICAuY29uY2F0KHBhdGhzLm1hcChtYXBQYXRoID0+IHBhdGgucmVzb2x2ZShyZWxhdGl2ZVRvLCBtYXBQYXRoKSkpXG4gICAgLmNvbmNhdChwYXRocy5tYXAobWFwUGF0aCA9PiBwYXRoLnJlc29sdmUocmVsYXRpdmVUbywgJ25vZGVfbW9kdWxlcycsIG1hcFBhdGgpKSk7XG4gIGQoJ3NlYXJjaGluZycsIHRlc3RQYXRocywgJ3JlbGF0aXZlIHRvJywgcmVsYXRpdmVUbyk7XG4gIGZvciAoY29uc3QgdGVzdFBhdGggb2YgdGVzdFBhdGhzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGQoJ3Rlc3RpbmcnLCB0ZXN0UGF0aCk7XG4gICAgICByZXR1cm4gcmVxdWlyZSh0ZXN0UGF0aCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJZ25vcmUgdGhlIGVycm9yXG4gICAgfVxuICB9XG4gIGQoJ2ZhaWxlZCB0byBmaW5kIGEgbW9kdWxlIGluJywgdGVzdFBhdGhzKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB0eXBlIFBvc3NpYmxlTW9kdWxlPFQ+ID0ge1xuICBkZWZhdWx0PzogVDtcbn0gJiBUO1xuXG5leHBvcnQgZGVmYXVsdCA8VD4ocmVsYXRpdmVUbzogc3RyaW5nLCBwYXRoczogc3RyaW5nW10pOiBUIHwgbnVsbCA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IHJlcXVpcmVTZWFyY2hSYXc8UG9zc2libGVNb2R1bGU8VD4+KHJlbGF0aXZlVG8sIHBhdGhzKTtcbiAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHJlc3VsdCAmJiByZXN1bHQuZGVmYXVsdCA/IHJlc3VsdC5kZWZhdWx0IDogcmVzdWx0IGFzIChUIHwgbnVsbCk7XG59O1xuIl19