"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getElectronVersion = getElectronVersion;
exports.updateElectronDependency = updateElectronDependency;

require("source-map-support/register");

var _debug = _interopRequireDefault(require("debug"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _semver = _interopRequireDefault(require("semver"));

var _yarnOrNpm = _interopRequireDefault(require("./yarn-or-npm"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const d = (0, _debug.default)('electron-forge:electron-version');
const electronPackageNames = ['electron-prebuilt-compile', 'electron-prebuilt', 'electron-nightly', 'electron'];

function findElectronDep(dep) {
  return electronPackageNames.includes(dep);
}

function getElectronVersion(_x, _x2) {
  return _getElectronVersion.apply(this, arguments);
}

function _getElectronVersion() {
  _getElectronVersion = _asyncToGenerator(function* (dir, packageJSON) {
    if (!packageJSON.devDependencies) {
      throw new Error('package.json for app does not have any devDependencies'.red);
    }

    const packageName = electronPackageNames.find(pkg => packageJSON.devDependencies[pkg]);

    if (packageName === undefined) {
      throw new Error('Could not find any Electron packages in devDependencies');
    }

    let version = packageJSON.devDependencies[packageName];

    if (!_semver.default.valid(version)) {
      // It's not an exact version, find it in the actual module
      const electronPackageJSONPath = _path.default.join(dir, 'node_modules', packageName, 'package.json');

      if (yield _fsExtra.default.pathExists(electronPackageJSONPath)) {
        const electronPackageJSON = yield _fsExtra.default.readJson(electronPackageJSONPath);
        version = electronPackageJSON.version;
      } else {
        throw new Error(`Cannot find the package "${packageName}". Perhaps you need to run "${(0, _yarnOrNpm.default)()} install" in "${dir}"?`);
      }
    }

    return version;
  });
  return _getElectronVersion.apply(this, arguments);
}

function updateElectronDependency(packageJSON, dev, exact) {
  const alteredDev = [].concat(dev);
  let alteredExact = [].concat(exact);

  if (Object.keys(packageJSON.devDependencies).find(findElectronDep)) {
    alteredExact = alteredExact.filter(dep => dep !== 'electron');
  } else {
    const electronKey = Object.keys(packageJSON.dependencies).find(findElectronDep);

    if (electronKey) {
      alteredExact = alteredExact.filter(dep => dep !== 'electron');
      d(`Moving ${electronKey} from dependencies to devDependencies`);
      alteredDev.push(`${electronKey}@${packageJSON.dependencies[electronKey]}`);
      delete packageJSON.dependencies[electronKey];
    }
  }

  return [alteredDev, alteredExact];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2VsZWN0cm9uLXZlcnNpb24udHMiXSwibmFtZXMiOlsiZCIsImVsZWN0cm9uUGFja2FnZU5hbWVzIiwiZmluZEVsZWN0cm9uRGVwIiwiZGVwIiwiaW5jbHVkZXMiLCJnZXRFbGVjdHJvblZlcnNpb24iLCJkaXIiLCJwYWNrYWdlSlNPTiIsImRldkRlcGVuZGVuY2llcyIsIkVycm9yIiwicmVkIiwicGFja2FnZU5hbWUiLCJmaW5kIiwicGtnIiwidW5kZWZpbmVkIiwidmVyc2lvbiIsInNlbXZlciIsInZhbGlkIiwiZWxlY3Ryb25QYWNrYWdlSlNPTlBhdGgiLCJwYXRoIiwiam9pbiIsImZzIiwicGF0aEV4aXN0cyIsImVsZWN0cm9uUGFja2FnZUpTT04iLCJyZWFkSnNvbiIsInVwZGF0ZUVsZWN0cm9uRGVwZW5kZW5jeSIsImRldiIsImV4YWN0IiwiYWx0ZXJlZERldiIsImNvbmNhdCIsImFsdGVyZWRFeGFjdCIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJlbGVjdHJvbktleSIsImRlcGVuZGVuY2llcyIsInB1c2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7QUFFQSxNQUFNQSxDQUFDLEdBQUcsb0JBQU0saUNBQU4sQ0FBVjtBQUVBLE1BQU1DLG9CQUFvQixHQUFHLENBQzNCLDJCQUQyQixFQUUzQixtQkFGMkIsRUFHM0Isa0JBSDJCLEVBSTNCLFVBSjJCLENBQTdCOztBQU9BLFNBQVNDLGVBQVQsQ0FBeUJDLEdBQXpCLEVBQStDO0FBQzdDLFNBQU9GLG9CQUFvQixDQUFDRyxRQUFyQixDQUE4QkQsR0FBOUIsQ0FBUDtBQUNEOztTQUVxQkUsa0I7Ozs7OzBDQUFmLFdBQWtDQyxHQUFsQyxFQUErQ0MsV0FBL0MsRUFBa0Y7QUFDdkYsUUFBSSxDQUFDQSxXQUFXLENBQUNDLGVBQWpCLEVBQWtDO0FBQ2hDLFlBQU0sSUFBSUMsS0FBSixDQUFVLHlEQUF5REMsR0FBbkUsQ0FBTjtBQUNEOztBQUNELFVBQU1DLFdBQVcsR0FBR1Ysb0JBQW9CLENBQUNXLElBQXJCLENBQTBCQyxHQUFHLElBQUlOLFdBQVcsQ0FBQ0MsZUFBWixDQUE0QkssR0FBNUIsQ0FBakMsQ0FBcEI7O0FBQ0EsUUFBSUYsV0FBVyxLQUFLRyxTQUFwQixFQUErQjtBQUM3QixZQUFNLElBQUlMLEtBQUosQ0FBVSx5REFBVixDQUFOO0FBQ0Q7O0FBRUQsUUFBSU0sT0FBTyxHQUFHUixXQUFXLENBQUNDLGVBQVosQ0FBNEJHLFdBQTVCLENBQWQ7O0FBQ0EsUUFBSSxDQUFDSyxnQkFBT0MsS0FBUCxDQUFhRixPQUFiLENBQUwsRUFBNEI7QUFDMUI7QUFDQSxZQUFNRyx1QkFBdUIsR0FBR0MsY0FBS0MsSUFBTCxDQUFVZCxHQUFWLEVBQWUsY0FBZixFQUErQkssV0FBL0IsRUFBNEMsY0FBNUMsQ0FBaEM7O0FBQ0EsZ0JBQVVVLGlCQUFHQyxVQUFILENBQWNKLHVCQUFkLENBQVYsRUFBa0Q7QUFDaEQsY0FBTUssbUJBQW1CLFNBQVNGLGlCQUFHRyxRQUFILENBQVlOLHVCQUFaLENBQWxDO0FBQ0FILFFBQUFBLE9BQU8sR0FBR1EsbUJBQW1CLENBQUNSLE9BQTlCO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsY0FBTSxJQUFJTixLQUFKLENBQVcsNEJBQTJCRSxXQUFZLCtCQUE4Qix5QkFBWSxpQkFBZ0JMLEdBQUksSUFBaEgsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsV0FBT1MsT0FBUDtBQUNELEc7Ozs7QUFFTSxTQUFTVSx3QkFBVCxDQUFrQ2xCLFdBQWxDLEVBQW9EbUIsR0FBcEQsRUFBbUVDLEtBQW5FLEVBQTBHO0FBQy9HLFFBQU1DLFVBQVUsR0FBSSxFQUFELENBQWlCQyxNQUFqQixDQUF3QkgsR0FBeEIsQ0FBbkI7QUFDQSxNQUFJSSxZQUFZLEdBQUksRUFBRCxDQUFpQkQsTUFBakIsQ0FBd0JGLEtBQXhCLENBQW5COztBQUNBLE1BQUlJLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZekIsV0FBVyxDQUFDQyxlQUF4QixFQUF5Q0ksSUFBekMsQ0FBOENWLGVBQTlDLENBQUosRUFBb0U7QUFDbEU0QixJQUFBQSxZQUFZLEdBQUdBLFlBQVksQ0FBQ0csTUFBYixDQUFvQjlCLEdBQUcsSUFBSUEsR0FBRyxLQUFLLFVBQW5DLENBQWY7QUFDRCxHQUZELE1BRU87QUFDTCxVQUFNK0IsV0FBVyxHQUFHSCxNQUFNLENBQUNDLElBQVAsQ0FBWXpCLFdBQVcsQ0FBQzRCLFlBQXhCLEVBQXNDdkIsSUFBdEMsQ0FBMkNWLGVBQTNDLENBQXBCOztBQUNBLFFBQUlnQyxXQUFKLEVBQWlCO0FBQ2ZKLE1BQUFBLFlBQVksR0FBR0EsWUFBWSxDQUFDRyxNQUFiLENBQW9COUIsR0FBRyxJQUFJQSxHQUFHLEtBQUssVUFBbkMsQ0FBZjtBQUNBSCxNQUFBQSxDQUFDLENBQUUsVUFBU2tDLFdBQVksdUNBQXZCLENBQUQ7QUFDQU4sTUFBQUEsVUFBVSxDQUFDUSxJQUFYLENBQWlCLEdBQUVGLFdBQVksSUFBRzNCLFdBQVcsQ0FBQzRCLFlBQVosQ0FBeUJELFdBQXpCLENBQXNDLEVBQXhFO0FBQ0EsYUFBTzNCLFdBQVcsQ0FBQzRCLFlBQVosQ0FBeUJELFdBQXpCLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQU8sQ0FBQ04sVUFBRCxFQUFhRSxZQUFiLENBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5pbXBvcnQgeWFybk9yTnBtIGZyb20gJy4veWFybi1vci1ucG0nO1xuXG5jb25zdCBkID0gZGVidWcoJ2VsZWN0cm9uLWZvcmdlOmVsZWN0cm9uLXZlcnNpb24nKTtcblxuY29uc3QgZWxlY3Ryb25QYWNrYWdlTmFtZXMgPSBbXG4gICdlbGVjdHJvbi1wcmVidWlsdC1jb21waWxlJyxcbiAgJ2VsZWN0cm9uLXByZWJ1aWx0JyxcbiAgJ2VsZWN0cm9uLW5pZ2h0bHknLFxuICAnZWxlY3Ryb24nLFxuXTtcblxuZnVuY3Rpb24gZmluZEVsZWN0cm9uRGVwKGRlcDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBlbGVjdHJvblBhY2thZ2VOYW1lcy5pbmNsdWRlcyhkZXApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RWxlY3Ryb25WZXJzaW9uKGRpcjogc3RyaW5nLCBwYWNrYWdlSlNPTjogYW55KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgaWYgKCFwYWNrYWdlSlNPTi5kZXZEZXBlbmRlbmNpZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhY2thZ2UuanNvbiBmb3IgYXBwIGRvZXMgbm90IGhhdmUgYW55IGRldkRlcGVuZGVuY2llcycucmVkKTtcbiAgfVxuICBjb25zdCBwYWNrYWdlTmFtZSA9IGVsZWN0cm9uUGFja2FnZU5hbWVzLmZpbmQocGtnID0+IHBhY2thZ2VKU09OLmRldkRlcGVuZGVuY2llc1twa2ddKTtcbiAgaWYgKHBhY2thZ2VOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGFueSBFbGVjdHJvbiBwYWNrYWdlcyBpbiBkZXZEZXBlbmRlbmNpZXMnKTtcbiAgfVxuXG4gIGxldCB2ZXJzaW9uID0gcGFja2FnZUpTT04uZGV2RGVwZW5kZW5jaWVzW3BhY2thZ2VOYW1lXTtcbiAgaWYgKCFzZW12ZXIudmFsaWQodmVyc2lvbikpIHtcbiAgICAvLyBJdCdzIG5vdCBhbiBleGFjdCB2ZXJzaW9uLCBmaW5kIGl0IGluIHRoZSBhY3R1YWwgbW9kdWxlXG4gICAgY29uc3QgZWxlY3Ryb25QYWNrYWdlSlNPTlBhdGggPSBwYXRoLmpvaW4oZGlyLCAnbm9kZV9tb2R1bGVzJywgcGFja2FnZU5hbWUsICdwYWNrYWdlLmpzb24nKTtcbiAgICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhlbGVjdHJvblBhY2thZ2VKU09OUGF0aCkpIHtcbiAgICAgIGNvbnN0IGVsZWN0cm9uUGFja2FnZUpTT04gPSBhd2FpdCBmcy5yZWFkSnNvbihlbGVjdHJvblBhY2thZ2VKU09OUGF0aCk7XG4gICAgICB2ZXJzaW9uID0gZWxlY3Ryb25QYWNrYWdlSlNPTi52ZXJzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIHRoZSBwYWNrYWdlIFwiJHtwYWNrYWdlTmFtZX1cIi4gUGVyaGFwcyB5b3UgbmVlZCB0byBydW4gXCIke3lhcm5Pck5wbSgpfSBpbnN0YWxsXCIgaW4gXCIke2Rpcn1cIj9gKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmVyc2lvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUVsZWN0cm9uRGVwZW5kZW5jeShwYWNrYWdlSlNPTjogYW55LCBkZXY6IHN0cmluZ1tdLCBleGFjdDogc3RyaW5nW10pOiBbc3RyaW5nW10sIHN0cmluZ1tdXSB7XG4gIGNvbnN0IGFsdGVyZWREZXYgPSAoW10gYXMgc3RyaW5nW10pLmNvbmNhdChkZXYpO1xuICBsZXQgYWx0ZXJlZEV4YWN0ID0gKFtdIGFzIHN0cmluZ1tdKS5jb25jYXQoZXhhY3QpO1xuICBpZiAoT2JqZWN0LmtleXMocGFja2FnZUpTT04uZGV2RGVwZW5kZW5jaWVzKS5maW5kKGZpbmRFbGVjdHJvbkRlcCkpIHtcbiAgICBhbHRlcmVkRXhhY3QgPSBhbHRlcmVkRXhhY3QuZmlsdGVyKGRlcCA9PiBkZXAgIT09ICdlbGVjdHJvbicpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGVsZWN0cm9uS2V5ID0gT2JqZWN0LmtleXMocGFja2FnZUpTT04uZGVwZW5kZW5jaWVzKS5maW5kKGZpbmRFbGVjdHJvbkRlcCk7XG4gICAgaWYgKGVsZWN0cm9uS2V5KSB7XG4gICAgICBhbHRlcmVkRXhhY3QgPSBhbHRlcmVkRXhhY3QuZmlsdGVyKGRlcCA9PiBkZXAgIT09ICdlbGVjdHJvbicpO1xuICAgICAgZChgTW92aW5nICR7ZWxlY3Ryb25LZXl9IGZyb20gZGVwZW5kZW5jaWVzIHRvIGRldkRlcGVuZGVuY2llc2ApO1xuICAgICAgYWx0ZXJlZERldi5wdXNoKGAke2VsZWN0cm9uS2V5fUAke3BhY2thZ2VKU09OLmRlcGVuZGVuY2llc1tlbGVjdHJvbktleV19YCk7XG4gICAgICBkZWxldGUgcGFja2FnZUpTT04uZGVwZW5kZW5jaWVzW2VsZWN0cm9uS2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2FsdGVyZWREZXYsIGFsdGVyZWRFeGFjdF07XG59XG4iXX0=