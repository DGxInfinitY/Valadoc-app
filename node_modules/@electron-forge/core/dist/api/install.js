"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

require("colors");

var _asyncOra = require("@electron-forge/async-ora");

var _installerBase = _interopRequireDefault(require("@electron-forge/installer-base"));

var _debug = _interopRequireDefault(require("debug"));

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _pify = _interopRequireDefault(require("pify"));

var _semver = _interopRequireDefault(require("semver"));

var _installerDmg = _interopRequireDefault(require("@electron-forge/installer-dmg"));

var _installerZip = _interopRequireDefault(require("@electron-forge/installer-zip"));

var _installerDeb = _interopRequireDefault(require("@electron-forge/installer-deb"));

var _installerRpm = _interopRequireDefault(require("@electron-forge/installer-rpm"));

var _installerExe = _interopRequireDefault(require("@electron-forge/installer-exe"));

var _messages = require("../util/messages");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const nugget = require('nugget');

const d = (0, _debug.default)('electron-forge:install');
const GITHUB_API = 'https://api.github.com';

class InstallerImpl extends _installerBase.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "name", 'impl');
  }

}

var _default =
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(function* ({
    interactive = false,
    prerelease = false,
    repo,
    chooseAsset
  }) {
    _asyncOra.asyncOra.interactive = interactive;

    if (typeof chooseAsset !== 'function') {
      throw 'Expected chooseAsset to be a function in install call';
    }

    let latestRelease;
    let possibleAssets = [];
    yield (0, _asyncOra.asyncOra)('Searching for Application',
    /*#__PURE__*/
    function () {
      var _ref2 = _asyncToGenerator(function* (searchSpinner) {
        if (!repo || repo.indexOf('/') === -1) {
          throw 'Invalid repository name, must be in the format owner/name';
        }

        d('searching for repo:', repo);
        let releases;

        try {
          releases = yield (yield (0, _nodeFetch.default)(`${GITHUB_API}/repos/${repo}/releases`)).json();
        } catch (err) {// Ignore error
        }

        if (!releases || releases.message === 'Not Found' || !Array.isArray(releases)) {
          throw `Failed to find releases for repository "${repo}".  Please check the name and try again.`;
        }

        if (releases.length === 0) {
          throw `Repository "${repo}" has no releases`;
        }

        releases = releases.filter(release => !release.prerelease || prerelease);
        const sortedReleases = releases.sort((releaseA, releaseB) => {
          let tagA = releaseA.tag_name;
          if (tagA.substr(0, 1) === 'v') tagA = tagA.substr(1);
          let tagB = releaseB.tag_name;
          if (tagB.substr(0, 1) === 'v') tagB = tagB.substr(1);
          return _semver.default.gt(tagB, tagA) ? 1 : -1;
        });
        latestRelease = sortedReleases[0];
        searchSpinner.text = 'Searching for Releases'; // eslint-disable-line

        const assets = latestRelease.assets;

        if (!assets || !Array.isArray(assets) || assets.length === 0) {
          throw 'Could not find any assets for the latest release';
        }

        const installTargets = {
          win32: [/\.exe$/],
          darwin: [/OSX.*\.zip$/, /darwin.*\.zip$/, /macOS.*\.zip$/, /mac.*\.zip$/, /\.dmg$/],
          linux: [/\.rpm$/, /\.deb$/]
        };
        possibleAssets = assets.filter(asset => {
          const targetSuffixes = installTargets[process.platform];
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = targetSuffixes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              const suffix = _step.value;
              if (suffix.test(asset.name)) return true;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return false;
        });

        if (possibleAssets.length === 0) {
          throw `Failed to find any installable assets for target platform: ${`${process.platform}`.cyan}`;
        }
      });

      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }());
    (0, _messages.info)(interactive, `Found latest release${prerelease ? ' (including prereleases)' : ''}: ${latestRelease.tag_name.cyan}`);
    let targetAsset = possibleAssets[0];

    if (possibleAssets.length > 1) {
      targetAsset = yield Promise.resolve(chooseAsset(possibleAssets));
    }

    const tmpdir = _path.default.resolve(_os.default.tmpdir(), 'forge-install');

    const pathSafeRepo = repo.replace(/[/\\]/g, '-');
    const filename = `${pathSafeRepo}-${latestRelease.tag_name}-${targetAsset.name}`;

    const fullFilePath = _path.default.resolve(tmpdir, filename);

    if (!(yield _fsExtra.default.pathExists(fullFilePath)) || (yield _fsExtra.default.stat(fullFilePath)).size !== targetAsset.size) {
      yield _fsExtra.default.mkdirs(tmpdir);
      const nuggetOpts = {
        target: filename,
        dir: tmpdir,
        resume: true,
        strictSSL: true
      };
      yield (0, _pify.default)(nugget)(targetAsset.browser_download_url, nuggetOpts);
    }

    yield (0, _asyncOra.asyncOra)('Installing Application',
    /*#__PURE__*/
    function () {
      var _ref3 = _asyncToGenerator(function* (installSpinner) {
        const installActions = {
          win32: {
            '.exe': _installerExe.default
          },
          darwin: {
            '.zip': _installerZip.default,
            '.dmg': _installerDmg.default
          },
          linux: {
            '.deb': _installerDeb.default,
            '.rpm': _installerRpm.default
          }
        };
        const suffixFnIdent = Object.keys(installActions[process.platform]).find(suffix => targetAsset.name.endsWith(suffix));

        if (!suffixFnIdent) {
          throw `No installer to handle "${targetAsset.name}"`;
        }

        const InstallerClass = installActions[process.platform][suffixFnIdent];
        const installer = new InstallerClass();
        yield installer.install({
          installSpinner,
          filePath: fullFilePath
        });
      });

      return function (_x3) {
        return _ref3.apply(this, arguments);
      };
    }());
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvaW5zdGFsbC50cyJdLCJuYW1lcyI6WyJudWdnZXQiLCJyZXF1aXJlIiwiZCIsIkdJVEhVQl9BUEkiLCJJbnN0YWxsZXJJbXBsIiwiSW5zdGFsbGVyQmFzZSIsImludGVyYWN0aXZlIiwicHJlcmVsZWFzZSIsInJlcG8iLCJjaG9vc2VBc3NldCIsImFzeW5jT3JhIiwibGF0ZXN0UmVsZWFzZSIsInBvc3NpYmxlQXNzZXRzIiwic2VhcmNoU3Bpbm5lciIsImluZGV4T2YiLCJyZWxlYXNlcyIsImpzb24iLCJlcnIiLCJtZXNzYWdlIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiZmlsdGVyIiwicmVsZWFzZSIsInNvcnRlZFJlbGVhc2VzIiwic29ydCIsInJlbGVhc2VBIiwicmVsZWFzZUIiLCJ0YWdBIiwidGFnX25hbWUiLCJzdWJzdHIiLCJ0YWdCIiwic2VtdmVyIiwiZ3QiLCJ0ZXh0IiwiYXNzZXRzIiwiaW5zdGFsbFRhcmdldHMiLCJ3aW4zMiIsImRhcndpbiIsImxpbnV4IiwiYXNzZXQiLCJ0YXJnZXRTdWZmaXhlcyIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsInN1ZmZpeCIsInRlc3QiLCJuYW1lIiwiY3lhbiIsInRhcmdldEFzc2V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0bXBkaXIiLCJwYXRoIiwib3MiLCJwYXRoU2FmZVJlcG8iLCJyZXBsYWNlIiwiZmlsZW5hbWUiLCJmdWxsRmlsZVBhdGgiLCJmcyIsInBhdGhFeGlzdHMiLCJzdGF0Iiwic2l6ZSIsIm1rZGlycyIsIm51Z2dldE9wdHMiLCJ0YXJnZXQiLCJkaXIiLCJyZXN1bWUiLCJzdHJpY3RTU0wiLCJicm93c2VyX2Rvd25sb2FkX3VybCIsImluc3RhbGxTcGlubmVyIiwiaW5zdGFsbEFjdGlvbnMiLCJFeGVJbnN0YWxsZXIiLCJaaXBJbnN0YWxsZXIiLCJETUdJbnN0YWxsZXIiLCJEZWJJbnN0YWxsZXIiLCJSUE1JbnN0YWxsZXIiLCJzdWZmaXhGbklkZW50IiwiT2JqZWN0Iiwia2V5cyIsImZpbmQiLCJlbmRzV2l0aCIsIkluc3RhbGxlckNsYXNzIiwiaW5zdGFsbGVyIiwiaW5zdGFsbCIsImZpbGVQYXRoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7OztBQUVBLE1BQU1BLE1BQU0sR0FBR0MsT0FBTyxDQUFDLFFBQUQsQ0FBdEI7O0FBRUEsTUFBTUMsQ0FBQyxHQUFHLG9CQUFNLHdCQUFOLENBQVY7QUFFQSxNQUFNQyxVQUFVLEdBQUcsd0JBQW5COztBQUVBLE1BQU1DLGFBQU4sU0FBNEJDLHNCQUE1QixDQUEwQztBQUFBO0FBQUE7O0FBQUEsa0NBQVMsTUFBVDtBQUFBOztBQUFBOzs7OzsrQkFrQzNCLFdBQU87QUFDcEJDLElBQUFBLFdBQVcsR0FBRyxLQURNO0FBRXBCQyxJQUFBQSxVQUFVLEdBQUcsS0FGTztBQUdwQkMsSUFBQUEsSUFIb0I7QUFJcEJDLElBQUFBO0FBSm9CLEdBQVAsRUFLTztBQUNwQkMsdUJBQVNKLFdBQVQsR0FBdUJBLFdBQXZCOztBQUVBLFFBQUksT0FBT0csV0FBUCxLQUF1QixVQUEzQixFQUF1QztBQUNyQyxZQUFNLHVEQUFOO0FBQ0Q7O0FBRUQsUUFBSUUsYUFBSjtBQUNBLFFBQUlDLGNBQXVCLEdBQUcsRUFBOUI7QUFFQSxVQUFNLHdCQUFTLDJCQUFUO0FBQUE7QUFBQTtBQUFBLG9DQUFzQyxXQUFPQyxhQUFQLEVBQXlCO0FBQ25FLFlBQUksQ0FBQ0wsSUFBRCxJQUFTQSxJQUFJLENBQUNNLE9BQUwsQ0FBYSxHQUFiLE1BQXNCLENBQUMsQ0FBcEMsRUFBdUM7QUFDckMsZ0JBQU0sMkRBQU47QUFDRDs7QUFFRFosUUFBQUEsQ0FBQyxDQUFDLHFCQUFELEVBQXdCTSxJQUF4QixDQUFEO0FBQ0EsWUFBSU8sUUFBSjs7QUFDQSxZQUFJO0FBQ0ZBLFVBQUFB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RCxHIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdjb2xvcnMnO1xuaW1wb3J0IHsgYXN5bmNPcmEgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvYXN5bmMtb3JhJztcbmltcG9ydCBJbnN0YWxsZXJCYXNlIGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9pbnN0YWxsZXItYmFzZSc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IGZldGNoIGZyb20gJ25vZGUtZmV0Y2gnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCBvcyBmcm9tICdvcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBwaWZ5IGZyb20gJ3BpZnknO1xuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xuXG5pbXBvcnQgRE1HSW5zdGFsbGVyIGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9pbnN0YWxsZXItZG1nJztcbmltcG9ydCBaaXBJbnN0YWxsZXIgZnJvbSAnQGVsZWN0cm9uLWZvcmdlL2luc3RhbGxlci16aXAnO1xuaW1wb3J0IERlYkluc3RhbGxlciBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvaW5zdGFsbGVyLWRlYic7XG5pbXBvcnQgUlBNSW5zdGFsbGVyIGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9pbnN0YWxsZXItcnBtJztcbmltcG9ydCBFeGVJbnN0YWxsZXIgZnJvbSAnQGVsZWN0cm9uLWZvcmdlL2luc3RhbGxlci1leGUnO1xuXG5pbXBvcnQgeyBpbmZvIH0gZnJvbSAnLi4vdXRpbC9tZXNzYWdlcyc7XG5cbmNvbnN0IG51Z2dldCA9IHJlcXVpcmUoJ251Z2dldCcpO1xuXG5jb25zdCBkID0gZGVidWcoJ2VsZWN0cm9uLWZvcmdlOmluc3RhbGwnKTtcblxuY29uc3QgR0lUSFVCX0FQSSA9ICdodHRwczovL2FwaS5naXRodWIuY29tJztcblxuY2xhc3MgSW5zdGFsbGVySW1wbCBleHRlbmRzIEluc3RhbGxlckJhc2UgeyBuYW1lID0gJ2ltcGwnOyB9XG5cbmludGVyZmFjZSBSZWxlYXNlIHtcbiAgdGFnX25hbWU6IHN0cmluZztcbiAgcHJlcmVsZWFzZTogYm9vbGVhbjtcbiAgYXNzZXRzOiBBc3NldFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFzc2V0IHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBzaXplOiBudW1iZXI7XG4gIGJyb3dzZXJfZG93bmxvYWRfdXJsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5zdGFsbE9wdGlvbnMge1xuICAvKipcbiAgICogV2hldGhlciB0byB1c2Ugc2Vuc2libGUgZGVmYXVsdHMgb3IgcHJvbXB0IHRoZSB1c2VyIHZpc3VhbGx5XG4gICAqL1xuICBpbnRlcmFjdGl2ZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGluc3RhbGwgcHJlcmVsZWFzZSB2ZXJzaW9uc1xuICAgKi9cbiAgcHJlcmVsZWFzZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUaGUgR2l0SHViIHJlcG9zaXRvcnkgdG8gaW5zdGFsbCBmcm9tLCBpbiB0aGUgZm9ybWF0IG93bmVyL25hbWVcbiAgICovXG4gIHJlcG86IHN0cmluZztcbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiB0aGUgYXNzZXQgdG8gdXNlL2luc3RhbGwgZnJvbSBhIHByb3ZpZGVkIGFycmF5IG9mIGNvbXBhdGlibGUgR2l0SHViIGFzc2V0c1xuICAgKi9cbiAgY2hvb3NlQXNzZXQ6IChhc3NldHM6IEFzc2V0W10pID0+IFByb21pc2U8QXNzZXQ+IHwgQXNzZXQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jICh7XG4gIGludGVyYWN0aXZlID0gZmFsc2UsXG4gIHByZXJlbGVhc2UgPSBmYWxzZSxcbiAgcmVwbyxcbiAgY2hvb3NlQXNzZXQsXG59OiBJbnN0YWxsT3B0aW9ucykgPT4ge1xuICBhc3luY09yYS5pbnRlcmFjdGl2ZSA9IGludGVyYWN0aXZlO1xuXG4gIGlmICh0eXBlb2YgY2hvb3NlQXNzZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyAnRXhwZWN0ZWQgY2hvb3NlQXNzZXQgdG8gYmUgYSBmdW5jdGlvbiBpbiBpbnN0YWxsIGNhbGwnO1xuICB9XG5cbiAgbGV0IGxhdGVzdFJlbGVhc2UhOiBSZWxlYXNlO1xuICBsZXQgcG9zc2libGVBc3NldHM6IEFzc2V0W10gPSBbXTtcblxuICBhd2FpdCBhc3luY09yYSgnU2VhcmNoaW5nIGZvciBBcHBsaWNhdGlvbicsIGFzeW5jIChzZWFyY2hTcGlubmVyKSA9PiB7XG4gICAgaWYgKCFyZXBvIHx8IHJlcG8uaW5kZXhPZignLycpID09PSAtMSkge1xuICAgICAgdGhyb3cgJ0ludmFsaWQgcmVwb3NpdG9yeSBuYW1lLCBtdXN0IGJlIGluIHRoZSBmb3JtYXQgb3duZXIvbmFtZSc7XG4gICAgfVxuXG4gICAgZCgnc2VhcmNoaW5nIGZvciByZXBvOicsIHJlcG8pO1xuICAgIGxldCByZWxlYXNlcyE6IFJlbGVhc2VbXTtcbiAgICB0cnkge1xuICAgICAgcmVsZWFzZXMgPSBhd2FpdCAoYXdhaXQgZmV0Y2goYCR7R0lUSFVCX0FQSX0vcmVwb3MvJHtyZXBvfS9yZWxlYXNlc2ApKS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJZ25vcmUgZXJyb3JcbiAgICB9XG5cbiAgICBpZiAoIXJlbGVhc2VzIHx8IChyZWxlYXNlcyBhcyBhbnkpLm1lc3NhZ2UgPT09ICdOb3QgRm91bmQnIHx8ICFBcnJheS5pc0FycmF5KHJlbGVhc2VzKSkge1xuICAgICAgdGhyb3cgYEZhaWxlZCB0byBmaW5kIHJlbGVhc2VzIGZvciByZXBvc2l0b3J5IFwiJHtyZXBvfVwiLiAgUGxlYXNlIGNoZWNrIHRoZSBuYW1lIGFuZCB0cnkgYWdhaW4uYDtcbiAgICB9XG5cbiAgICBpZiAocmVsZWFzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBgUmVwb3NpdG9yeSBcIiR7cmVwb31cIiBoYXMgbm8gcmVsZWFzZXNgO1xuICAgIH1cblxuICAgIHJlbGVhc2VzID0gcmVsZWFzZXMuZmlsdGVyKHJlbGVhc2UgPT4gIXJlbGVhc2UucHJlcmVsZWFzZSB8fCBwcmVyZWxlYXNlKTtcblxuICAgIGNvbnN0IHNvcnRlZFJlbGVhc2VzID0gcmVsZWFzZXMuc29ydCgocmVsZWFzZUEsIHJlbGVhc2VCKSA9PiB7XG4gICAgICBsZXQgdGFnQSA9IHJlbGVhc2VBLnRhZ19uYW1lO1xuICAgICAgaWYgKHRhZ0Euc3Vic3RyKDAsIDEpID09PSAndicpIHRhZ0EgPSB0YWdBLnN1YnN0cigxKTtcbiAgICAgIGxldCB0YWdCID0gcmVsZWFzZUIudGFnX25hbWU7XG4gICAgICBpZiAodGFnQi5zdWJzdHIoMCwgMSkgPT09ICd2JykgdGFnQiA9IHRhZ0Iuc3Vic3RyKDEpO1xuICAgICAgcmV0dXJuIChzZW12ZXIuZ3QodGFnQiwgdGFnQSkgPyAxIDogLTEpO1xuICAgIH0pO1xuICAgIGxhdGVzdFJlbGVhc2UgPSBzb3J0ZWRSZWxlYXNlc1swXTtcblxuICAgIHNlYXJjaFNwaW5uZXIudGV4dCA9ICdTZWFyY2hpbmcgZm9yIFJlbGVhc2VzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgY29uc3QgYXNzZXRzID0gbGF0ZXN0UmVsZWFzZS5hc3NldHM7XG4gICAgaWYgKCFhc3NldHMgfHwgIUFycmF5LmlzQXJyYXkoYXNzZXRzKSB8fCBhc3NldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyAnQ291bGQgbm90IGZpbmQgYW55IGFzc2V0cyBmb3IgdGhlIGxhdGVzdCByZWxlYXNlJztcbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YWxsVGFyZ2V0czoge1xuICAgICAgW2tleTogc3RyaW5nXTogUmVnRXhwW107XG4gICAgfSA9IHtcbiAgICAgIHdpbjMyOiBbL1xcLmV4ZSQvXSxcbiAgICAgIGRhcndpbjogWy9PU1guKlxcLnppcCQvLCAvZGFyd2luLipcXC56aXAkLywgL21hY09TLipcXC56aXAkLywgL21hYy4qXFwuemlwJC8sIC9cXC5kbWckL10sXG4gICAgICBsaW51eDogWy9cXC5ycG0kLywgL1xcLmRlYiQvXSxcbiAgICB9O1xuXG4gICAgcG9zc2libGVBc3NldHMgPSBhc3NldHMuZmlsdGVyKChhc3NldCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0U3VmZml4ZXMgPSBpbnN0YWxsVGFyZ2V0c1twcm9jZXNzLnBsYXRmb3JtXTtcbiAgICAgIGZvciAoY29uc3Qgc3VmZml4IG9mIHRhcmdldFN1ZmZpeGVzKSB7XG4gICAgICAgIGlmIChzdWZmaXgudGVzdChhc3NldC5uYW1lKSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBpZiAocG9zc2libGVBc3NldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBgRmFpbGVkIHRvIGZpbmQgYW55IGluc3RhbGxhYmxlIGFzc2V0cyBmb3IgdGFyZ2V0IHBsYXRmb3JtOiAke2Ake3Byb2Nlc3MucGxhdGZvcm19YC5jeWFufWA7XG4gICAgfVxuICB9KTtcblxuICBpbmZvKGludGVyYWN0aXZlLCBgRm91bmQgbGF0ZXN0IHJlbGVhc2Uke3ByZXJlbGVhc2UgPyAnIChpbmNsdWRpbmcgcHJlcmVsZWFzZXMpJyA6ICcnfTogJHtsYXRlc3RSZWxlYXNlLnRhZ19uYW1lLmN5YW59YCk7XG5cbiAgbGV0IHRhcmdldEFzc2V0ID0gcG9zc2libGVBc3NldHNbMF07XG4gIGlmIChwb3NzaWJsZUFzc2V0cy5sZW5ndGggPiAxKSB7XG4gICAgdGFyZ2V0QXNzZXQgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoY2hvb3NlQXNzZXQocG9zc2libGVBc3NldHMpKTtcbiAgfVxuXG4gIGNvbnN0IHRtcGRpciA9IHBhdGgucmVzb2x2ZShvcy50bXBkaXIoKSwgJ2ZvcmdlLWluc3RhbGwnKTtcbiAgY29uc3QgcGF0aFNhZmVSZXBvID0gcmVwby5yZXBsYWNlKC9bL1xcXFxdL2csICctJyk7XG4gIGNvbnN0IGZpbGVuYW1lID0gYCR7cGF0aFNhZmVSZXBvfS0ke2xhdGVzdFJlbGVhc2UudGFnX25hbWV9LSR7dGFyZ2V0QXNzZXQubmFtZX1gO1xuXG4gIGNvbnN0IGZ1bGxGaWxlUGF0aCA9IHBhdGgucmVzb2x2ZSh0bXBkaXIsIGZpbGVuYW1lKTtcbiAgaWYgKCFhd2FpdCBmcy5wYXRoRXhpc3RzKGZ1bGxGaWxlUGF0aCkgfHwgKGF3YWl0IGZzLnN0YXQoZnVsbEZpbGVQYXRoKSkuc2l6ZSAhPT0gdGFyZ2V0QXNzZXQuc2l6ZSkge1xuICAgIGF3YWl0IGZzLm1rZGlycyh0bXBkaXIpO1xuXG4gICAgY29uc3QgbnVnZ2V0T3B0cyA9IHtcbiAgICAgIHRhcmdldDogZmlsZW5hbWUsXG4gICAgICBkaXI6IHRtcGRpcixcbiAgICAgIHJlc3VtZTogdHJ1ZSxcbiAgICAgIHN0cmljdFNTTDogdHJ1ZSxcbiAgICB9O1xuICAgIGF3YWl0IHBpZnkobnVnZ2V0KSh0YXJnZXRBc3NldC5icm93c2VyX2Rvd25sb2FkX3VybCwgbnVnZ2V0T3B0cyk7XG4gIH1cblxuICBhd2FpdCBhc3luY09yYSgnSW5zdGFsbGluZyBBcHBsaWNhdGlvbicsIGFzeW5jIChpbnN0YWxsU3Bpbm5lcikgPT4ge1xuICAgIGNvbnN0IGluc3RhbGxBY3Rpb25zOiB7XG4gICAgICBba2V5OiBzdHJpbmddOiB7XG4gICAgICAgIFtrZXk6IHN0cmluZ106IHR5cGVvZiBJbnN0YWxsZXJJbXBsO1xuICAgICAgfTtcbiAgICB9ID0ge1xuICAgICAgd2luMzI6IHtcbiAgICAgICAgJy5leGUnOiBFeGVJbnN0YWxsZXIsXG4gICAgICB9LFxuICAgICAgZGFyd2luOiB7XG4gICAgICAgICcuemlwJzogWmlwSW5zdGFsbGVyLFxuICAgICAgICAnLmRtZyc6IERNR0luc3RhbGxlcixcbiAgICAgIH0sXG4gICAgICBsaW51eDoge1xuICAgICAgICAnLmRlYic6IERlYkluc3RhbGxlcixcbiAgICAgICAgJy5ycG0nOiBSUE1JbnN0YWxsZXIsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBjb25zdCBzdWZmaXhGbklkZW50ID0gT2JqZWN0LmtleXMoaW5zdGFsbEFjdGlvbnNbcHJvY2Vzcy5wbGF0Zm9ybV0pLmZpbmQoc3VmZml4ID0+IHRhcmdldEFzc2V0Lm5hbWUuZW5kc1dpdGgoc3VmZml4KSk7XG4gICAgaWYgKCFzdWZmaXhGbklkZW50KSB7XG4gICAgICB0aHJvdyBgTm8gaW5zdGFsbGVyIHRvIGhhbmRsZSBcIiR7dGFyZ2V0QXNzZXQubmFtZX1cImA7XG4gICAgfVxuICAgIGNvbnN0IEluc3RhbGxlckNsYXNzID0gaW5zdGFsbEFjdGlvbnNbcHJvY2Vzcy5wbGF0Zm9ybV1bc3VmZml4Rm5JZGVudF07XG4gICAgY29uc3QgaW5zdGFsbGVyID0gbmV3IEluc3RhbGxlckNsYXNzKCk7XG4gICAgYXdhaXQgaW5zdGFsbGVyLmluc3RhbGwoeyBpbnN0YWxsU3Bpbm5lciwgZmlsZVBhdGg6IGZ1bGxGaWxlUGF0aCB9KTtcbiAgfSk7XG59O1xuIl19