"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

require("colors");

var _asyncOra = require("@electron-forge/async-ora");

var _makerBase = _interopRequireDefault(require("@electron-forge/maker-base"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _forgeConfig = _interopRequireDefault(require("../util/forge-config"));

var _hook = require("../util/hook");

var _messages = require("../util/messages");

var _parseArchs = _interopRequireDefault(require("../util/parse-archs"));

var _readPackageJson = require("../util/read-package-json");

var _resolveDir = _interopRequireDefault(require("../util/resolve-dir"));

var _outDir = _interopRequireDefault(require("../util/out-dir"));

var _electronVersion = require("../util/electron-version");

var _requireSearch = _interopRequireDefault(require("../util/require-search"));

var _package = _interopRequireDefault(require("./package"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const _require = require('electron-download/lib/arch'),
      hostArch = _require.host;

class MakerImpl extends _makerBase.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "name", 'impl');

    _defineProperty(this, "defaultPlatforms", []);
  }

}

var _default =
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(function* ({
    dir = process.cwd(),
    interactive = false,
    skipPackage = false,
    arch = hostArch(),
    platform = process.platform,
    overrideTargets,
    outDir
  }) {
    _asyncOra.asyncOra.interactive = interactive;
    let forgeConfig;
    yield (0, _asyncOra.asyncOra)('Resolving Forge Config',
    /*#__PURE__*/
    _asyncToGenerator(function* () {
      const resolvedDir = yield (0, _resolveDir.default)(dir);

      if (!resolvedDir) {
        throw 'Failed to locate makeable Electron application';
      }

      dir = resolvedDir;
      forgeConfig = yield (0, _forgeConfig.default)(dir);
    }));
    const actualOutDir = outDir || (0, _outDir.default)(dir, forgeConfig);
    const actualTargetPlatform = platform;
    platform = platform === 'mas' ? 'darwin' : platform;

    if (!['darwin', 'win32', 'linux', 'mas'].includes(actualTargetPlatform)) {
      throw new Error(`'${actualTargetPlatform}' is an invalid platform. Choices are 'darwin', 'mas', 'win32' or 'linux'`);
    }

    const makers = {};
    let targets = (overrideTargets || forgeConfig.makers).map(target => {
      if (typeof target === 'string') {
        return {
          name: target
        };
      }

      return target;
    });
    let targetId = 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = targets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const target = _step.value;
        let maker;

        if (target.__isElectronForgeMaker) {
          maker = target;
          if (maker.platforms.indexOf(actualTargetPlatform) === -1) continue;
        } else {
          const resolvableTarget = target;
          const MakerClass = (0, _requireSearch.default)(dir, [resolvableTarget.name]);

          if (!MakerClass) {
            throw `Could not find module with name: ${resolvableTarget.name}`;
          }

          maker = new MakerClass(resolvableTarget.config, resolvableTarget.platforms || undefined);
          if (maker.platforms.indexOf(actualTargetPlatform) === -1) continue;
        }

        if (!maker.isSupportedOnCurrentPlatform) {
          throw new Error([`Maker for target ${maker.name} is incompatible with this version of `, 'electron-forge, please upgrade or contact the maintainer ', '(needs to implement \'isSupportedOnCurrentPlatform)\')'].join(''));
        }

        if (!(yield maker.isSupportedOnCurrentPlatform())) {
          throw new Error([`Cannot make for ${platform} and target ${maker.name}: the maker declared `, `that it cannot run on ${process.platform}`].join(''));
        }

        makers[targetId] = maker;
        targetId += 1;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (!skipPackage) {
      (0, _messages.info)(interactive, 'We need to package your application before we can make it'.green);
      yield (0, _package.default)({
        dir,
        interactive,
        arch,
        outDir: actualOutDir,
        platform: actualTargetPlatform
      });
    } else {
      (0, _messages.warn)(interactive, 'WARNING: Skipping the packaging step, this could result in an out of date build'.red);
    }

    targets = targets.filter((_, i) => makers[i]);
    (0, _messages.info)(interactive, `Making for the following targets: ${`${targets.map((t, i) => makers[i].name).join(', ')}`.cyan}`);
    const packageJSON = yield (0, _readPackageJson.readMutatedPackageJson)(dir, forgeConfig);
    const appName = forgeConfig.packagerConfig.name || packageJSON.productName || packageJSON.name;
    const outputs = [];
    yield (0, _hook.runHook)(forgeConfig, 'preMake');
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = (0, _parseArchs.default)(platform, arch, (yield (0, _electronVersion.getElectronVersion)(dir, packageJSON)))[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        const targetArch = _step2.value;

        const packageDir = _path.default.resolve(actualOutDir, `${appName}-${actualTargetPlatform}-${targetArch}`);

        if (!(yield _fsExtra.default.pathExists(packageDir))) {
          throw new Error(`Couldn't find packaged app at: ${packageDir}`);
        }

        targetId = 0;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = targets[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            const target = _step3.value;
            const maker = makers[targetId];
            targetId += 1; // eslint-disable-next-line no-loop-func

            yield (0, _asyncOra.asyncOra)(`Making for target: ${maker.name.green} - On platform: ${actualTargetPlatform.cyan} - For arch: ${targetArch.cyan}`,
            /*#__PURE__*/
            _asyncToGenerator(function* () {
              try {
                /**
                 * WARNING: DO NOT ATTEMPT TO PARALLELIZE MAKERS
                 *
                 * Currently it is assumed we have 1 maker per make call but that is
                 * not enforced.  It is technically possible to have 1 maker be called
                 * multiple times.  The "prepareConfig" method however implicitly
                 * requires a lock that is not enforced.  There are two options:
                 *
                 *   * Provide makers a getConfig() method
                 *   * Remove support for config being provided as a method
                 *   * Change the entire API of maker from a single constructor to
                 *     providing a MakerFactory
                 */
                maker.prepareConfig(targetArch);
                const artifacts = yield maker.make({
                  appName,
                  forgeConfig,
                  packageJSON,
                  targetArch,
                  dir: packageDir,
                  makeDir: _path.default.resolve(actualOutDir, 'make'),
                  targetPlatform: actualTargetPlatform
                });
                outputs.push({
                  artifacts,
                  packageJSON,
                  platform: actualTargetPlatform,
                  arch: targetArch
                });
              } catch (err) {
                if (err) {
                  throw {
                    message: `An error occured while making for target: ${maker.name}`,
                    stack: `${err.message}\n${err.stack}`
                  };
                } else {
                  throw new Error(`An unknown error occured while making for target: ${maker.name}`);
                }
              }
            }));
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      } // If the postMake hooks modifies the locations / names of the outputs it must return
      // the new locations so that the publish step knows where to look

    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return yield (0, _hook.runMutatingHook)(forgeConfig, 'postMake', outputs);
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvbWFrZS50cyJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiaG9zdEFyY2giLCJob3N0IiwiTWFrZXJJbXBsIiwiTWFrZXJCYXNlIiwiZGlyIiwicHJvY2VzcyIsImN3ZCIsImludGVyYWN0aXZlIiwic2tpcFBhY2thZ2UiLCJhcmNoIiwicGxhdGZvcm0iLCJvdmVycmlkZVRhcmdldHMiLCJvdXREaXIiLCJhc3luY09yYSIsImZvcmdlQ29uZmlnIiwicmVzb2x2ZWREaXIiLCJhY3R1YWxPdXREaXIiLCJhY3R1YWxUYXJnZXRQbGF0Zm9ybSIsImluY2x1ZGVzIiwiRXJyb3IiLCJtYWtlcnMiLCJ0YXJnZXRzIiwibWFwIiwidGFyZ2V0IiwibmFtZSIsInRhcmdldElkIiwibWFrZXIiLCJfX2lzRWxlY3Ryb25Gb3JnZU1ha2VyIiwicGxhdGZvcm1zIiwiaW5kZXhPZiIsInJlc29sdmFibGVUYXJnZXQiLCJNYWtlckNsYXNzIiwiY29uZmlnIiwidW5kZWZpbmVkIiwiaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSIsImpvaW4iLCJncmVlbiIsInJlZCIsImZpbHRlciIsIl8iLCJpIiwidCIsImN5YW4iLCJwYWNrYWdlSlNPTiIsImFwcE5hbWUiLCJwYWNrYWdlckNvbmZpZyIsInByb2R1Y3ROYW1lIiwib3V0cHV0cyIsInRhcmdldEFyY2giLCJwYWNrYWdlRGlyIiwicGF0aCIsInJlc29sdmUiLCJmcyIsInBhdGhFeGlzdHMiLCJwcmVwYXJlQ29uZmlnIiwiYXJ0aWZhY3RzIiwibWFrZSIsIm1ha2VEaXIiLCJ0YXJnZXRQbGF0Zm9ybSIsInB1c2giLCJlcnIiLCJtZXNzYWdlIiwic3RhY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOzs7Ozs7Ozs7O2lCQUVzREEsT0FBTyxDQUFDLDRC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QUFLLENBQUNGLElBQUssRUFBMUUsQ0FBTjtBQUNEO0FBQ0Y7QUFDRixhQTFDSyxFQUFOO0FBMkNEO0FBdkQ4RjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBd0RoRyxPQXBKZ0IsQ0FzSmpCO0FBQ0E7O0FBdkppQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQXdKakIsaUJBQWEsMkJBQWdCVixXQUFoQixFQUE2QixVQUE3QixFQUF5Q2lDLE9BQXpDLENBQWI7QUFDRCxHIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdjb2xvcnMnO1xuaW1wb3J0IHsgYXN5bmNPcmEgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvYXN5bmMtb3JhJztcbmltcG9ydCB7IElGb3JnZVJlc29sdmFibGVNYWtlciwgRm9yZ2VDb25maWcsIEZvcmdlQXJjaCwgRm9yZ2VQbGF0Zm9ybSwgRm9yZ2VNYWtlUmVzdWx0IH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL3NoYXJlZC10eXBlcyc7XG5pbXBvcnQgTWFrZXJCYXNlIGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9tYWtlci1iYXNlJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IGdldEZvcmdlQ29uZmlnIGZyb20gJy4uL3V0aWwvZm9yZ2UtY29uZmlnJztcbmltcG9ydCB7IHJ1bkhvb2ssIHJ1bk11dGF0aW5nSG9vayB9IGZyb20gJy4uL3V0aWwvaG9vayc7XG5pbXBvcnQgeyBpbmZvLCB3YXJuIH0gZnJvbSAnLi4vdXRpbC9tZXNzYWdlcyc7XG5pbXBvcnQgcGFyc2VBcmNocyBmcm9tICcuLi91dGlsL3BhcnNlLWFyY2hzJztcbmltcG9ydCB7IHJlYWRNdXRhdGVkUGFja2FnZUpzb24gfSBmcm9tICcuLi91dGlsL3JlYWQtcGFja2FnZS1qc29uJztcbmltcG9ydCByZXNvbHZlRGlyIGZyb20gJy4uL3V0aWwvcmVzb2x2ZS1kaXInO1xuaW1wb3J0IGdldEN1cnJlbnRPdXREaXIgZnJvbSAnLi4vdXRpbC9vdXQtZGlyJztcbmltcG9ydCB7IGdldEVsZWN0cm9uVmVyc2lvbiB9IGZyb20gJy4uL3V0aWwvZWxlY3Ryb24tdmVyc2lvbic7XG5pbXBvcnQgcmVxdWlyZVNlYXJjaCBmcm9tICcuLi91dGlsL3JlcXVpcmUtc2VhcmNoJztcblxuaW1wb3J0IHBhY2thZ2VyIGZyb20gJy4vcGFja2FnZSc7XG5cbmNvbnN0IHsgaG9zdDogaG9zdEFyY2ggfTogeyBob3N0OiAoKSA9PiBGb3JnZUFyY2ggfSA9IHJlcXVpcmUoJ2VsZWN0cm9uLWRvd25sb2FkL2xpYi9hcmNoJyk7XG5cbmNsYXNzIE1ha2VySW1wbCBleHRlbmRzIE1ha2VyQmFzZTxhbnk+IHsgbmFtZSA9ICdpbXBsJzsgZGVmYXVsdFBsYXRmb3JtcyA9IFtdOyB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFrZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHBhdGggdG8gdGhlIGFwcCBmcm9tIHdoaWNoIGRpc3RydWJ1dGFibGVzIGFyZSBnZW5lcmF0ZWRcbiAgICovXG4gIGRpcj86IHN0cmluZztcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gdXNlIHNlbnNpYmxlIGRlZmF1bHRzIG9yIHByb21wdCB0aGUgdXNlciB2aXN1YWxseVxuICAgKi9cbiAgaW50ZXJhY3RpdmU/OiBib29sZWFuO1xuICAvKipcbiAgICogV2hldGhlciB0byBza2lwIHRoZSBwcmUtbWFrZSBwYWNrYWdpbmcgc3RlcFxuICAgKi9cbiAgc2tpcFBhY2thZ2U/OiBib29sZWFuO1xuICAvKipcbiAgICogQW4gYXJyYXkgb2YgbWFrZSB0YXJnZXRzIHRvIG92ZXJyaWRlIHlvdXIgZm9yZ2UgY29uZmlnXG4gICAqL1xuICBvdmVycmlkZVRhcmdldHM/OiAoSUZvcmdlUmVzb2x2YWJsZU1ha2VyIHwgTWFrZXJCYXNlPGFueT4pW107XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IGFyY2hpdGVjdHVyZVxuICAgKi9cbiAgYXJjaD86IEZvcmdlQXJjaDtcbiAgLyoqXG4gICAqIFRoZSB0YXJnZXQgcGxhdGZvcm1cbiAgICovXG4gIHBsYXRmb3JtPzogRm9yZ2VQbGF0Zm9ybTtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIHRoZSBkaXJlY3RvcnkgY29udGFpbmluZyBnZW5lcmF0ZWQgZGlzdHJpYnV0YWJsZXNcbiAgICovXG4gIG91dERpcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKHtcbiAgZGlyID0gcHJvY2Vzcy5jd2QoKSxcbiAgaW50ZXJhY3RpdmUgPSBmYWxzZSxcbiAgc2tpcFBhY2thZ2UgPSBmYWxzZSxcbiAgYXJjaCA9IGhvc3RBcmNoKCksXG4gIHBsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybSBhcyBGb3JnZVBsYXRmb3JtLFxuICBvdmVycmlkZVRhcmdldHMsXG4gIG91dERpcixcbn06IE1ha2VPcHRpb25zKSA9PiB7XG5cbiAgYXN5bmNPcmEuaW50ZXJhY3RpdmUgPSBpbnRlcmFjdGl2ZTtcblxuICBsZXQgZm9yZ2VDb25maWchOiBGb3JnZUNvbmZpZztcbiAgYXdhaXQgYXN5bmNPcmEoJ1Jlc29sdmluZyBGb3JnZSBDb25maWcnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWREaXIgPSBhd2FpdCByZXNvbHZlRGlyKGRpcik7XG4gICAgaWYgKCFyZXNvbHZlZERpcikge1xuICAgICAgdGhyb3cgJ0ZhaWxlZCB0byBsb2NhdGUgbWFrZWFibGUgRWxlY3Ryb24gYXBwbGljYXRpb24nO1xuICAgIH1cbiAgICBkaXIgPSByZXNvbHZlZERpcjtcblxuICAgIGZvcmdlQ29uZmlnID0gYXdhaXQgZ2V0Rm9yZ2VDb25maWcoZGlyKTtcbiAgfSk7XG5cbiAgY29uc3QgYWN0dWFsT3V0RGlyID0gb3V0RGlyIHx8IGdldEN1cnJlbnRPdXREaXIoZGlyLCBmb3JnZUNvbmZpZyk7XG5cbiAgY29uc3QgYWN0dWFsVGFyZ2V0UGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgcGxhdGZvcm0gPSBwbGF0Zm9ybSA9PT0gJ21hcycgPyAnZGFyd2luJyA6IHBsYXRmb3JtO1xuICBpZiAoIVsnZGFyd2luJywgJ3dpbjMyJywgJ2xpbnV4JywgJ21hcyddLmluY2x1ZGVzKGFjdHVhbFRhcmdldFBsYXRmb3JtKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJyR7YWN0dWFsVGFyZ2V0UGxhdGZvcm19JyBpcyBhbiBpbnZhbGlkIHBsYXRmb3JtLiBDaG9pY2VzIGFyZSAnZGFyd2luJywgJ21hcycsICd3aW4zMicgb3IgJ2xpbnV4J2ApO1xuICB9XG5cbiAgY29uc3QgbWFrZXJzOiB7XG4gICAgW2tleTogbnVtYmVyXTogTWFrZXJCYXNlPGFueT47XG4gIH0gPSB7fTtcbiAgbGV0IHRhcmdldHMgPSAob3ZlcnJpZGVUYXJnZXRzIHx8IGZvcmdlQ29uZmlnLm1ha2VycykubWFwKCh0YXJnZXQpID0+IHtcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB7IG5hbWU6IHRhcmdldCB9O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9KTtcblxuICBsZXQgdGFyZ2V0SWQgPSAwO1xuICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgbGV0IG1ha2VyOiBNYWtlckJhc2U8YW55PjtcbiAgICBpZiAoKHRhcmdldCBhcyBNYWtlckJhc2U8YW55PikuX19pc0VsZWN0cm9uRm9yZ2VNYWtlcikge1xuICAgICAgbWFrZXIgPSB0YXJnZXQgYXMgTWFrZXJCYXNlPGFueT47XG4gICAgICBpZiAobWFrZXIucGxhdGZvcm1zLmluZGV4T2YoYWN0dWFsVGFyZ2V0UGxhdGZvcm0pID09PSAtMSkgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc29sdmFibGVUYXJnZXQ6IElGb3JnZVJlc29sdmFibGVNYWtlciA9IHRhcmdldCBhcyBJRm9yZ2VSZXNvbHZhYmxlTWFrZXI7XG4gICAgICBjb25zdCBNYWtlckNsYXNzID0gcmVxdWlyZVNlYXJjaDx0eXBlb2YgTWFrZXJJbXBsPihkaXIsIFtyZXNvbHZhYmxlVGFyZ2V0Lm5hbWVdKTtcbiAgICAgIGlmICghTWFrZXJDbGFzcykge1xuICAgICAgICB0aHJvdyBgQ291bGQgbm90IGZpbmQgbW9kdWxlIHdpdGggbmFtZTogJHtyZXNvbHZhYmxlVGFyZ2V0Lm5hbWV9YDtcbiAgICAgIH1cblxuICAgICAgbWFrZXIgPSBuZXcgTWFrZXJDbGFzcyhyZXNvbHZhYmxlVGFyZ2V0LmNvbmZpZywgcmVzb2x2YWJsZVRhcmdldC5wbGF0Zm9ybXMgfHwgdW5kZWZpbmVkKTtcbiAgICAgIGlmIChtYWtlci5wbGF0Zm9ybXMuaW5kZXhPZihhY3R1YWxUYXJnZXRQbGF0Zm9ybSkgPT09IC0xKSBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoIW1ha2VyLmlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgIGBNYWtlciBmb3IgdGFyZ2V0ICR7bWFrZXIubmFtZX0gaXMgaW5jb21wYXRpYmxlIHdpdGggdGhpcyB2ZXJzaW9uIG9mIGAsXG4gICAgICAgICdlbGVjdHJvbi1mb3JnZSwgcGxlYXNlIHVwZ3JhZGUgb3IgY29udGFjdCB0aGUgbWFpbnRhaW5lciAnLFxuICAgICAgICAnKG5lZWRzIHRvIGltcGxlbWVudCBcXCdpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtKVxcJyknLFxuICAgICAgXS5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgaWYgKCFhd2FpdCBtYWtlci5pc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgIGBDYW5ub3QgbWFrZSBmb3IgJHtwbGF0Zm9ybX0gYW5kIHRhcmdldCAke21ha2VyLm5hbWV9OiB0aGUgbWFrZXIgZGVjbGFyZWQgYCxcbiAgICAgICAgYHRoYXQgaXQgY2Fubm90IHJ1biBvbiAke3Byb2Nlc3MucGxhdGZvcm19YCxcbiAgICAgIF0uam9pbignJykpO1xuICAgIH1cblxuICAgIG1ha2Vyc1t0YXJnZXRJZF0gPSBtYWtlcjtcbiAgICB0YXJnZXRJZCArPSAxO1xuICB9XG5cbiAgaWYgKCFza2lwUGFja2FnZSkge1xuICAgIGluZm8oaW50ZXJhY3RpdmUsICdXZSBuZWVkIHRvIHBhY2thZ2UgeW91ciBhcHBsaWNhdGlvbiBiZWZvcmUgd2UgY2FuIG1ha2UgaXQnLmdyZWVuKTtcbiAgICBhd2FpdCBwYWNrYWdlcih7XG4gICAgICBkaXIsXG4gICAgICBpbnRlcmFjdGl2ZSxcbiAgICAgIGFyY2gsXG4gICAgICBvdXREaXI6IGFjdHVhbE91dERpcixcbiAgICAgIHBsYXRmb3JtOiBhY3R1YWxUYXJnZXRQbGF0Zm9ybSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB3YXJuKGludGVyYWN0aXZlLCAnV0FSTklORzogU2tpcHBpbmcgdGhlIHBhY2thZ2luZyBzdGVwLCB0aGlzIGNvdWxkIHJlc3VsdCBpbiBhbiBvdXQgb2YgZGF0ZSBidWlsZCcucmVkKTtcbiAgfVxuXG4gIHRhcmdldHMgPSB0YXJnZXRzLmZpbHRlcigoXywgaSkgPT4gbWFrZXJzW2ldKTtcblxuICBpbmZvKGludGVyYWN0aXZlLCBgTWFraW5nIGZvciB0aGUgZm9sbG93aW5nIHRhcmdldHM6ICR7YCR7dGFyZ2V0cy5tYXAoKHQsIGkpID0+IG1ha2Vyc1tpXS5uYW1lKS5qb2luKCcsICcpfWAuY3lhbn1gKTtcblxuICBjb25zdCBwYWNrYWdlSlNPTiA9IGF3YWl0IHJlYWRNdXRhdGVkUGFja2FnZUpzb24oZGlyLCBmb3JnZUNvbmZpZyk7XG4gIGNvbnN0IGFwcE5hbWUgPSBmb3JnZUNvbmZpZy5wYWNrYWdlckNvbmZpZy5uYW1lIHx8IHBhY2thZ2VKU09OLnByb2R1Y3ROYW1lIHx8IHBhY2thZ2VKU09OLm5hbWU7XG4gIGNvbnN0IG91dHB1dHM6IEZvcmdlTWFrZVJlc3VsdFtdID0gW107XG5cbiAgYXdhaXQgcnVuSG9vayhmb3JnZUNvbmZpZywgJ3ByZU1ha2UnKTtcblxuICBmb3IgKGNvbnN0IHRhcmdldEFyY2ggb2YgcGFyc2VBcmNocyhwbGF0Zm9ybSwgYXJjaCwgYXdhaXQgZ2V0RWxlY3Ryb25WZXJzaW9uKGRpciwgcGFja2FnZUpTT04pKSkge1xuICAgIGNvbnN0IHBhY2thZ2VEaXIgPSBwYXRoLnJlc29sdmUoYWN0dWFsT3V0RGlyLCBgJHthcHBOYW1lfS0ke2FjdHVhbFRhcmdldFBsYXRmb3JtfS0ke3RhcmdldEFyY2h9YCk7XG4gICAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhwYWNrYWdlRGlyKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBwYWNrYWdlZCBhcHAgYXQ6ICR7cGFja2FnZURpcn1gKTtcbiAgICB9XG5cbiAgICB0YXJnZXRJZCA9IDA7XG4gICAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgICAgY29uc3QgbWFrZXIgPSBtYWtlcnNbdGFyZ2V0SWRdO1xuICAgICAgdGFyZ2V0SWQgKz0gMTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgYXdhaXQgYXN5bmNPcmEoYE1ha2luZyBmb3IgdGFyZ2V0OiAke21ha2VyLm5hbWUuZ3JlZW59IC0gT24gcGxhdGZvcm06ICR7YWN0dWFsVGFyZ2V0UGxhdGZvcm0uY3lhbn0gLSBGb3IgYXJjaDogJHt0YXJnZXRBcmNoLmN5YW59YCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdBUk5JTkc6IERPIE5PVCBBVFRFTVBUIFRPIFBBUkFMTEVMSVpFIE1BS0VSU1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogQ3VycmVudGx5IGl0IGlzIGFzc3VtZWQgd2UgaGF2ZSAxIG1ha2VyIHBlciBtYWtlIGNhbGwgYnV0IHRoYXQgaXNcbiAgICAgICAgICAgKiBub3QgZW5mb3JjZWQuICBJdCBpcyB0ZWNobmljYWxseSBwb3NzaWJsZSB0byBoYXZlIDEgbWFrZXIgYmUgY2FsbGVkXG4gICAgICAgICAgICogbXVsdGlwbGUgdGltZXMuICBUaGUgXCJwcmVwYXJlQ29uZmlnXCIgbWV0aG9kIGhvd2V2ZXIgaW1wbGljaXRseVxuICAgICAgICAgICAqIHJlcXVpcmVzIGEgbG9jayB0aGF0IGlzIG5vdCBlbmZvcmNlZC4gIFRoZXJlIGFyZSB0d28gb3B0aW9uczpcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICAgKiBQcm92aWRlIG1ha2VycyBhIGdldENvbmZpZygpIG1ldGhvZFxuICAgICAgICAgICAqICAgKiBSZW1vdmUgc3VwcG9ydCBmb3IgY29uZmlnIGJlaW5nIHByb3ZpZGVkIGFzIGEgbWV0aG9kXG4gICAgICAgICAgICogICAqIENoYW5nZSB0aGUgZW50aXJlIEFQSSBvZiBtYWtlciBmcm9tIGEgc2luZ2xlIGNvbnN0cnVjdG9yIHRvXG4gICAgICAgICAgICogICAgIHByb3ZpZGluZyBhIE1ha2VyRmFjdG9yeVxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1ha2VyLnByZXBhcmVDb25maWcodGFyZ2V0QXJjaCk7XG4gICAgICAgICAgY29uc3QgYXJ0aWZhY3RzID0gYXdhaXQgbWFrZXIubWFrZSh7XG4gICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgZm9yZ2VDb25maWcsXG4gICAgICAgICAgICBwYWNrYWdlSlNPTixcbiAgICAgICAgICAgIHRhcmdldEFyY2gsXG4gICAgICAgICAgICBkaXI6IHBhY2thZ2VEaXIsXG4gICAgICAgICAgICBtYWtlRGlyOiBwYXRoLnJlc29sdmUoYWN0dWFsT3V0RGlyLCAnbWFrZScpLFxuICAgICAgICAgICAgdGFyZ2V0UGxhdGZvcm06IGFjdHVhbFRhcmdldFBsYXRmb3JtLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgb3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgIGFydGlmYWN0cyxcbiAgICAgICAgICAgIHBhY2thZ2VKU09OLFxuICAgICAgICAgICAgcGxhdGZvcm06IGFjdHVhbFRhcmdldFBsYXRmb3JtLFxuICAgICAgICAgICAgYXJjaDogdGFyZ2V0QXJjaCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICBtZXNzYWdlOiBgQW4gZXJyb3Igb2NjdXJlZCB3aGlsZSBtYWtpbmcgZm9yIHRhcmdldDogJHttYWtlci5uYW1lfWAsXG4gICAgICAgICAgICAgIHN0YWNrOiBgJHtlcnIubWVzc2FnZX1cXG4ke2Vyci5zdGFja31gLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiB1bmtub3duIGVycm9yIG9jY3VyZWQgd2hpbGUgbWFraW5nIGZvciB0YXJnZXQ6ICR7bWFrZXIubmFtZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBwb3N0TWFrZSBob29rcyBtb2RpZmllcyB0aGUgbG9jYXRpb25zIC8gbmFtZXMgb2YgdGhlIG91dHB1dHMgaXQgbXVzdCByZXR1cm5cbiAgLy8gdGhlIG5ldyBsb2NhdGlvbnMgc28gdGhhdCB0aGUgcHVibGlzaCBzdGVwIGtub3dzIHdoZXJlIHRvIGxvb2tcbiAgcmV0dXJuIGF3YWl0IHJ1bk11dGF0aW5nSG9vayhmb3JnZUNvbmZpZywgJ3Bvc3RNYWtlJywgb3V0cHV0cyk7XG59O1xuIl19